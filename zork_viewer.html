<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZorkGPT Live Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }
        
        .game-container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            grid-template-rows: auto 1fr;
            gap: 20px;
            padding: 20px;
            height: 100vh;
            box-sizing: border-box;
        }
        
        /* Mobile responsive layout */
        @media (max-width: 768px) {
            .game-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto auto;
                height: auto;
                min-height: 100vh;
                padding: 10px;
                gap: 15px;
            }
            
            .game-info {
                grid-column: 1;
                grid-row: 1;
            }
            
            .game-log {
                grid-column: 1;
                grid-row: 2;
                max-height: 500px;
                overflow-y: auto;
            }
            
            .map-container {
                grid-column: 1;
                grid-row: 3;
                max-height: 400px;
                overflow-y: auto;
            }
            
            .knowledge-section {
                grid-column: 1;
                grid-row: 4;
                max-height: 400px;
                overflow-y: auto;
            }
        }
        
        /* Tablet responsive layout */
        @media (max-width: 1024px) and (min-width: 769px) {
            .game-container {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto 1fr 1fr;
                gap: 15px;
                padding: 15px;
            }
            
            .game-info {
                grid-column: 1 / -1;
                grid-row: 1;
            }
            
            .knowledge-section {
                grid-column: 1;
                grid-row: 2;
            }
            
            .game-log {
                grid-column: 2;
                grid-row: 2;
            }
            
            .map-container {
                grid-column: 1 / -1;
                grid-row: 3;
                max-height: 400px;
                overflow-y: auto;
            }
        }
        
        .game-info {
            grid-column: 1 / -1;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        /* Header styling */
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .header-links {
            display: flex;
            gap: 15px;
        }
        
        /* Mobile responsive header and info grid */
        @media (max-width: 768px) {
            .header-container {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
                margin-bottom: 10px;
            }
            
            .header-links {
                gap: 10px;
            }
            
            .info-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
                margin-top: 10px;
            }
        }
        
        .info-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        
        .map-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            overflow: auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .game-log {
            background: #1e1e1e;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            padding: 20px;
            border-radius: 12px;
            overflow-y: auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: relative;
            text-align: left;
        }
        
        .knowledge-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        
        .objectives-list {
            margin: 0 0 20px 0;
            padding: 0;
            list-style: none;
        }
        
        .objective-item {
            background: #f8f9fa;
            margin: 8px 0;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #28a745;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .objective-item:nth-child(even) {
            background: #e9ecef;
        }
        
        .objective-item strong {
            display: block;
            margin-bottom: 4px;
            color: #2c5530;
        }
        
        .objectives-divider {
            border: none;
            height: 2px;
            background: linear-gradient(to right, #dee2e6, #6c757d, #dee2e6);
            margin: 20px 0;
            border-radius: 1px;
        }
        
        .current-room {
            background: #ffeb3b;
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: bold;
            color: #333;
        }
        
        .log-entry {
            margin-bottom: 20px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }
        
        .log-turn-header {
            color: #00bfff;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .log-thinking {
            color: #ffeb3b;
            font-style: italic;
            margin: 8px 0;
            padding: 8px 12px;
            background: rgba(255, 235, 59, 0.1);
            border-left: 3px solid #ffeb3b;
            border-radius: 4px;
            font-size: 0.9em;
            line-height: 1.4;
        }
        
        .log-proposed-action {
            color: #87ceeb;
            margin: 8px 0;
            padding: 6px 12px;
            background: rgba(135, 206, 235, 0.1);
            border-left: 3px solid #87ceeb;
            border-radius: 4px;
        }
        
        .log-critic {
            color: #ffa500;
            margin: 8px 0;
            padding: 6px 12px;
            background: rgba(255, 165, 0, 0.1);
            border-left: 3px solid #ffa500;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        .log-action-taken {
            color: #98fb98;
            font-weight: bold;
            margin: 8px 0;
            padding: 6px 12px;
            background: rgba(152, 251, 152, 0.1);
            border-left: 3px solid #98fb98;
            border-radius: 4px;
        }
        
        .log-response {
            color: #90ee90;
            line-height: 1.4;
            margin: 8px 0;
            padding: 8px 12px;
            background: rgba(144, 238, 144, 0.05);
            border-radius: 4px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-connected {
            background-color: #28a745;
        }
        
        .status-disconnected {
            background-color: #dc3545;
        }
        
        .map-stats {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 14px;
            color: #666;
        }
        
        h1, h2, h3 {
            margin-top: 0;
            color: #333;
        }
        
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
        }
        
        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }
        
        /* Override any inherited centering */
        .game-log .loading {
            text-align: center !important;
        }
        
        .knowledge-section .loading {
            text-align: center !important;
        }
        
        /* Fix text alignment issues */
        .game-log * {
            text-align: left !important;
        }
        
        .knowledge-section {
            text-align: left !important;
        }
        
        .knowledge-section * {
            text-align: left !important;
        }
        
        .knowledge-section h1 {
            color: #333 !important;
            margin: 20px 0 15px 0 !important;
            font-size: 20px !important;
            text-align: left !important;
            font-weight: bold !important;
        }
        
        .knowledge-section h2 {
            color: #333 !important;
            margin: 18px 0 12px 0 !important;
            font-size: 18px !important;
            text-align: left !important;
            font-weight: bold !important;
        }
        
        .knowledge-section h3 {
            color: #444 !important;
            margin: 15px 0 10px 0 !important;
            font-size: 16px !important;
            text-align: left !important;
            font-weight: bold !important;
        }
        
        .knowledge-section h4 {
            color: #555 !important;
            margin: 12px 0 8px 0 !important;
            font-size: 14px !important;
            text-align: left !important;
            font-weight: bold !important;
        }
        
        .knowledge-section ul {
            margin: 10px 0 !important;
            padding-left: 20px !important;
            text-align: left !important;
        }
        
        .knowledge-section li {
            margin: 5px 0 !important;
            line-height: 1.4 !important;
            text-align: left !important;
        }
        
        .knowledge-section p {
            margin: 10px 0 !important;
            line-height: 1.5 !important;
            text-align: left !important;
        }
        
        .knowledge-section strong {
            font-weight: bold !important;
        }
        
        .knowledge-section em {
            font-style: italic !important;
        }
        
        .knowledge-section code {
            background-color: #f4f4f4 !important;
            padding: 2px 4px !important;
            border-radius: 3px !important;
            font-family: 'Courier New', monospace !important;
            font-size: 90% !important;
        }
        
        .knowledge-section pre {
            background-color: #f8f8f8 !important;
            padding: 10px !important;
            border-radius: 5px !important;
            overflow-x: auto !important;
            margin: 10px 0 !important;
        }
        
        .knowledge-section blockquote {
            border-left: 4px solid #ddd !important;
            margin: 10px 0 !important;
            padding-left: 15px !important;
            color: #666 !important;
            font-style: italic !important;
        }
        
        .knowledge-section table {
            border-collapse: collapse !important;
            width: 100% !important;
            margin: 10px 0 !important;
        }
        
        .knowledge-section th,
        .knowledge-section td {
            border: 1px solid #ddd !important;
            padding: 8px !important;
            text-align: left !important;
        }
        
        .knowledge-section th {
            background-color: #f2f2f2 !important;
            font-weight: bold !important;
        }
        
        /* New messages indicator */
        .new-messages-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: #007bff;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
        }
        
        .new-messages-indicator:hover {
            background: #0056b3;
        }
        
        /* FAQ Modal styling */
        .faq-modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        .faq-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        /* Map Modal styling */
        .map-modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 90vw;
            max-height: 90vh;
            width: 1200px;
            height: 800px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
        }
        
        .map-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-shrink: 0;
        }
        
        .map-modal-body {
            flex: 1;
            overflow: auto;
            display: flex;
            flex-direction: column;
        }
        
        #map-diagram-expanded {
            flex: 1;
            min-height: 500px;
            overflow: auto;
        }
        
        #map-stats-expanded {
            margin-top: 15px;
            flex-shrink: 0;
        }
        
        /* Mobile responsive FAQ modal */
        @media (max-width: 768px) {
            .faq-modal-content {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                transform: none;
                max-width: none;
                max-height: none;
                border-radius: 0;
                padding: 20px;
                margin: 0;
            }
            
            .faq-modal-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
                margin-bottom: 15px;
            }
            
            .faq-modal-header button {
                position: absolute !important;
                top: 15px !important;
                right: 15px !important;
            }
        }

        /* Mobile responsive map modal */
        @media (max-width: 768px) {
            .map-modal-content {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                transform: none;
                max-width: none;
                max-height: none;
                width: auto;
                height: auto;
                border-radius: 0;
                padding: 20px;
                margin: 0;
            }
            
            .map-modal-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
                margin-bottom: 15px;
            }
            
            .map-modal-header button {
                position: absolute !important;
                top: 15px !important;
                right: 15px !important;
            }
            
            #map-diagram-expanded {
                min-height: 300px;
            }
        }

        /* Historical Data Loading Styles */
        .load-earlier-container {
            text-align: center;
            margin: 15px 0;
            padding: 10px;
            border-bottom: 1px solid #333;
        }

        .load-earlier-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .load-earlier-btn:hover:not(:disabled) {
            background: #0056b3;
        }

        .load-earlier-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .historical-log-entry {
            opacity: 0.8;
            border-left: 3px solid #6c757d;
        }

        .log-turn-indicator {
            font-size: 0.9em;
            color: #00bfff;
            margin-bottom: 5px;
        }

        .historical-indicator {
            color: #ffa500;
            font-size: 0.8em;
            font-style: italic;
            margin-left: 8px;
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #6c757d;
            border-radius: 50%;
            border-top-color: #007bff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .episode-selector {
            margin: 10px 0;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 6px;
            border-bottom: 1px solid #333;
        }

        .episode-selector select {
            background: #1e1e1e;
            color: #00ff00;
            border: 1px solid #333;
            padding: 5px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        .historical-stats {
            font-size: 0.8em;
            color: #888;
            text-align: center;
            margin: 5px 0;
        }

        /* Episode Selector Styles */
        .episode-selector-trigger {
            cursor: pointer;
            color: #007bff;
            text-decoration: underline;
            position: relative;
        }

        .episode-selector-trigger:hover {
            color: #0056b3;
        }

        .episode-selector-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            max-height: 400px;
            overflow: hidden;
        }

        .episode-selector-header {
            padding: 12px 16px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #f8f9fa;
        }

        .episode-selector-header h4 {
            margin: 0;
            color: #333;
            font-size: 16px;
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: #333;
        }

        .episode-selector-content {
            max-height: 320px;
            overflow-y: auto;
        }

        .episode-list {
            padding: 8px;
        }

        .episode-item {
            padding: 12px;
            border: 1px solid #eee;
            border-radius: 6px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .episode-item:hover {
            background-color: #f8f9fa;
        }

        .episode-item.current {
            background-color: #e3f2fd;
            border-color: #2196f3;
        }

        .episode-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .episode-item-id {
            font-weight: bold;
            color: #333;
            font-size: 14px;
        }

        .episode-item-status {
            font-size: 12px;
            padding: 2px 6px;
            border-radius: 3px;
            color: white;
        }

        .episode-status-completed {
            background-color: #4caf50;
        }

        .episode-status-died {
            background-color: #f44336;
        }

        .episode-status-ongoing {
            background-color: #ff9800;
        }

        .episode-item-stats {
            font-size: 12px;
            color: #666;
            display: flex;
            gap: 12px;
        }

        .episode-item-stat {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Mobile responsive episode selector */
        @media (max-width: 768px) {
            .episode-selector-dropdown {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                max-height: none;
                border-radius: 0;
                border: none;
            }

            .episode-selector-content {
                max-height: calc(100vh - 60px);
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-info">
            <div class="header-container">
                <h1 style="margin: 0;">
                    <span class="status-indicator" id="connection-status"></span>
                    ZorkGPT Live Viewer
                </h1>
                <div class="header-links">
                    <a href="https://github.com/stickystyle/ZorkGPT" target="_blank" style="color: #007bff; text-decoration: none; font-weight: 500;">
                        üìÅ Project
                    </a>
                    <a href="#faq" onclick="showFAQ()" style="color: #007bff; text-decoration: none; font-weight: 500; cursor: pointer;">
                        ‚ùì FAQ
                    </a>
                </div>
            </div>
            <div class="info-grid">
                <div class="info-item" style="position: relative;">
                    <strong>Episode:</strong>
                    <span id="episode-id" class="episode-selector-trigger" title="Click to select episode">Loading...</span>
                    <div id="episode-selector" class="episode-selector-dropdown" style="display: none;">
                        <div class="episode-selector-header">
                            <h4>Select Episode</h4>
                            <button onclick="hideEpisodeSelector()" class="close-btn">&times;</button>
                        </div>
                        <div class="episode-selector-content">
                            <div id="episode-list" class="episode-list">
                                <div class="loading">Loading episodes...</div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="info-item">
                    <strong>Turn:</strong> <span id="turn-count">-</span> / <span id="max-turns">-</span>
                </div>
                <div class="info-item">
                    <strong>Score:</strong> <span id="score">-</span>
                </div>
                <div class="info-item">
                    <strong>Location:</strong> <span id="location" class="current-room">-</span>
                </div>
                <div class="info-item">
                    <strong>Inventory:</strong> <span id="inventory">-</span>
                </div>
                <div class="info-item">
                    <strong>Deaths:</strong> <span id="death-count">0</span>
                </div>
            </div>
        </div>
        
        <div class="knowledge-section">
            <h3 id="objectives-header">Current Objectives</h3>
            <div id="objectives-content" class="loading">Loading...</div>
            
            <hr class="objectives-divider">
            
            <h3>Knowledge Base</h3>
            <div id="knowledge-content" class="loading">Loading...</div>
        </div>
        
        <div class="game-log">
            <h3 style="color: #00bfff;">Recent Game Log</h3>
            <div id="recent-log" class="loading">Loading...</div>
            <div id="new-messages-indicator" class="new-messages-indicator">
                New messages ‚Üì
            </div>
        </div>
        
        <div class="map-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="margin: 0;">Game Map</h3>
                <button onclick="showExpandedMap()" style="background: #007bff; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;">
                    üîç Expand
                </button>
            </div>
            <div id="map-diagram" class="loading">Loading map...</div>
            <div id="map-stats" class="map-stats"></div>
        </div>
    </div>

    <!-- FAQ Modal -->
    <div id="faq-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000;">
        <div class="faq-modal-content">
            <div class="faq-modal-header">
                <h2 style="margin: 0; color: #333;">ZorkGPT Live Viewer FAQ</h2>
                <button onclick="hideFAQ()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">&times;</button>
            </div>
            <div style="line-height: 1.6; color: #444;">
                <h3>What is ZorkGPT?</h3>
                <p>ZorkGPT is an AI agent system that plays the classic interactive fiction game "Zork" using Large Language Models (LLMs). It demonstrates how AI can understand and navigate complex text-based game worlds.</p>
                
                <h3>What is Zork?</h3>
                <p><a href="https://en.wikipedia.org/wiki/Zork" target="_blank">Zork</a> is a legendary text adventure game first released in 1977, where players explore the Great Underground Empire by typing commands in natural language. Often considered the most famous piece of interactive fiction, Zork challenges players to solve puzzles, collect treasures, and navigate hundreds of locations using only text descriptions and typed commands.</p>
                
                <h3>Why Zork instead of Pokemon?</h3>
                <p>I've seen the impressive Claude and Gemini plays Pokemon projects and wanted to explore what was possible with open source models. Why didn't I try making open source models play Pokemon? Because I'm not as smart as the guys who created those projects! üòâ I originally tried to limit myself to models that could reasonably run on home systems configured for LLM inference, making this more accessible to hobbyists and researchers without massive compute budgets. However after thousands of turns, I've needed up expand to larger (still open source) models to get the best results.</p>
                
                <h3>What am I looking at?</h3>
                <p>This live viewer shows real-time data from a running ZorkGPT session, including:</p>
                <ul>
                    <li><strong>Game Info:</strong> Current episode, turn count, score, and location</li>
                    <li><strong>Knowledge Base:</strong> AI-generated strategic guides and learned patterns</li>
                    <li><strong>Game Log:</strong> Recent actions, AI reasoning, and game responses</li>
                    <li><strong>Map:</strong> Visual representation of discovered locations and connections</li>
                </ul>
                
                <h3>How does the AI work?</h3>
                <p>The system uses multiple AI components, each potentially running different open source models:</p>
                <ul>
                    <li><strong>Agent:</strong> Decides what actions to take</li>
                    <li><strong>Extractor:</strong> Parses game text into structured data</li>
                    <li><strong>Critic:</strong> Evaluates proposed actions before execution</li>
                    <li><strong>Knowledge Base:</strong> Analyzes gameplay data to generate strategic guides and learns from experience</li>
                </ul>
                <div id="current-models-info">
                    <p><strong>Current Models:</strong></p>
                    <ul>
                        <li><strong>Agent:</strong> <span id="faq-agent-model">Loading...</span></li>
                        <li><strong>Critic:</strong> <span id="faq-critic-model">Loading...</span></li>
                        <li><strong>Extractor:</strong> <span id="faq-extractor-model">Loading...</span></li>
                        <li><strong>Knowledge Base:</strong> <span id="faq-knowledge-model">Loading...</span></li>
                    </ul>
                </div>
                <p>These models may change as experiments progress to test different capabilities and performance characteristics.</p>
                
                <h3>Why isn't the data updating?</h3>
                <p>The viewer polls for updates every 3 seconds. If you see a red connection indicator, either:</p>
                <ul>
                    <li>No ZorkGPT session is currently running</li>
                    <li>The state file isn't being generated</li>
                    <li>The data is more than 10 minutes old (stale session)</li>
                    <li>There's a network connectivity issue</li>
                </ul>
                
                <h3>What do the log colors mean?</h3>
                <ul>
                    <li><span style="color: #ffeb3b;">üí≠ Yellow:</span> AI thinking/reasoning</li>
                    <li><span style="color: #87ceeb;">üéØ Light Blue:</span> Proposed action (final action taken)</li>
                    <li><span style="color: #ffa500;">üö´ Orange:</span> Rejected actions (if any) with critic justifications</li>
                    <li><span style="color: #ffa500;">‚öñÔ∏è Orange:</span> Final critic evaluation with detailed justification</li>
                    <li><span style="color: #98fb98;">‚úÖ Light Green:</span> Action taken</li>
                    <li><span style="color: #90ee90;">üéÆ Green:</span> Game response</li>
                </ul>
                
                <h3>What does the critic evaluation show?</h3>
                <p>The critic evaluation displays:</p>
                <ul>
                    <li><strong>Status:</strong> Whether the action was approved or rejected</li>
                    <li><strong>Score:</strong> Numerical evaluation (positive = good, negative = bad)</li>
                    <li><strong>Justification:</strong> Detailed reasoning for the evaluation</li>
                    <li><strong>Override status:</strong> Whether a rejected action was overridden</li>
                </ul>
                
                <h3>Can I interact with the game?</h3>
                <p>No, this is a read-only viewer. The AI is playing autonomously. You can watch its decision-making process and see how it learns and adapts.</p>
            </div>
        </div>
    </div>

    <!-- Expanded Map Modal -->
    <div id="map-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000;">
        <div class="map-modal-content">
            <div class="map-modal-header">
                <h2 style="margin: 0; color: #333;">Game Map - Expanded View</h2>
                <button onclick="hideExpandedMap()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">&times;</button>
            </div>
            <div class="map-modal-body">
                <div id="map-diagram-expanded" class="loading">Loading map...</div>
                <div id="map-stats-expanded" class="map-stats"></div>
            </div>
        </div>
    </div>

    <script>
        // Initialize Mermaid
        mermaid.initialize({ 
            startOnLoad: false,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true
            }
        });

        // Historical Data Manager for lazy-loading turn snapshots
        // IMPORTANT: Each turn_X.json contains a complete snapshot with recent_log containing multiple turns
        // We need to be smart about which snapshots to fetch and extract only the turns we need
        class HistoricalDataManager {
            constructor(baseUrl, episodeId) {
                this.baseUrl = baseUrl;
                this.episodeId = episodeId;
                this.turnCache = new Map(); // Cache individual turn entries
                this.snapshotCache = new Map(); // Cache full snapshots
                this.maxTurnCacheSize = 200; // More turns since they're smaller
                this.maxSnapshotCacheSize = 10; // Fewer snapshots since they're larger
                this.isLoading = false;
                this.loadedTurnSet = new Set(); // Track which individual turns we have
            }

            // Smart strategy: Determine which snapshot(s) to fetch for a given turn range
            determineSnapshotsNeeded(startTurn, endTurn) {
                const snapshots = [];
                
                // Strategy: Each snapshot turn_X.json typically contains recent_log with ~10-20 turns
                // We want to minimize snapshot fetches while covering our range
                
                // For efficiency, we'll fetch snapshots at strategic intervals
                // Assume each snapshot contains ~20 turns in recent_log
                const estimatedLogSize = 20;
                
                // Find the best snapshots to fetch
                // Start from the end of our range and work backwards
                let currentTurn = endTurn;
                
                while (currentTurn >= startTurn) {
                    // Check if we already have this snapshot cached
                    const snapshotKey = `${this.episodeId}_snapshot_${currentTurn}`;
                    
                    if (!this.snapshotCache.has(snapshotKey)) {
                        snapshots.push(currentTurn);
                    }
                    
                    // Move to the next strategic snapshot
                    // Go back by estimated log size to minimize overlap
                    currentTurn -= estimatedLogSize;
                }
                
                // Also try a few key snapshots that might contain our range
                const keySnapshots = [
                    endTurn, // Latest snapshot in range
                    Math.floor((startTurn + endTurn) / 2), // Middle snapshot
                    startTurn + 10 // Snapshot likely to contain start of range
                ].filter(turn => turn >= startTurn && turn <= endTurn);
                
                // Combine and deduplicate
                const allSnapshots = [...new Set([...snapshots, ...keySnapshots])];
                
                console.log(`For range ${startTurn}-${endTurn}, will try snapshots: ${allSnapshots.join(', ')}`);
                return allSnapshots;
            }

            async fetchSnapshot(episodeId, turnNumber) {
                const cacheKey = `${episodeId}_snapshot_${turnNumber}`;
                
                if (this.snapshotCache.has(cacheKey)) {
                    // Move to end for LRU
                    const value = this.snapshotCache.get(cacheKey);
                    this.snapshotCache.delete(cacheKey);
                    this.snapshotCache.set(cacheKey, value);
                    return value;
                }

                try {
                    const url = `${this.baseUrl}/snapshots/${episodeId}/turn_${turnNumber}.json`;
                    console.log(`Fetching snapshot: ${url}`);
                    
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        if (response.status === 404) {
                            console.warn(`Snapshot turn_${turnNumber}.json not found for episode ${episodeId}`);
                            return null;
                        }
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const snapshotData = await response.json();
                    
                    // Cache management - LRU eviction for snapshots
                    if (this.snapshotCache.size >= this.maxSnapshotCacheSize) {
                        const firstKey = this.snapshotCache.keys().next().value;
                        this.snapshotCache.delete(firstKey);
                    }
                    
                    this.snapshotCache.set(cacheKey, snapshotData);
                    return snapshotData;
                    
                } catch (error) {
                    console.warn(`Failed to fetch snapshot turn_${turnNumber}.json for episode ${episodeId}:`, error);
                    return null;
                }
            }

            // Extract specific turns from a snapshot's recent_log
            extractTurnsFromSnapshot(snapshot, neededTurns) {
                if (!snapshot || !snapshot.recent_log) {
                    return [];
                }
                
                const extractedTurns = [];
                const neededSet = new Set(neededTurns);
                
                for (const logEntry of snapshot.recent_log) {
                    if (neededSet.has(logEntry.turn)) {
                        // Mark as historical and add metadata
                        const turnEntry = {
                            ...logEntry,
                            _isHistorical: true,
                            _episodeId: snapshot.metadata?.episode_id,
                            _sourceSnapshot: snapshot.metadata?.turn_count
                        };
                        
                        extractedTurns.push(turnEntry);
                        
                        // Cache this individual turn
                        const turnCacheKey = `${this.episodeId}_turn_${logEntry.turn}`;
                        this.turnCache.set(turnCacheKey, turnEntry);
                        this.loadedTurnSet.add(logEntry.turn);
                        
                        // LRU management for turn cache
                        if (this.turnCache.size > this.maxTurnCacheSize) {
                            const firstKey = this.turnCache.keys().next().value;
                            const firstTurn = this.turnCache.get(firstKey);
                            this.turnCache.delete(firstKey);
                            if (firstTurn) {
                                this.loadedTurnSet.delete(firstTurn.turn);
                            }
                        }
                    }
                }
                
                console.log(`Extracted ${extractedTurns.length} turns from snapshot (turn ${snapshot.metadata?.turn_count})`);
                return extractedTurns;
            }

            async loadTurnRange(episodeId, startTurn, endTurn) {
                console.log(`Loading turn range: ${startTurn}-${endTurn} for episode ${episodeId}`);
                
                // First, check what turns we already have cached
                const neededTurns = [];
                for (let turn = startTurn; turn <= endTurn; turn++) {
                    if (!this.loadedTurnSet.has(turn)) {
                        neededTurns.push(turn);
                    }
                }
                
                if (neededTurns.length === 0) {
                    console.log(`All turns ${startTurn}-${endTurn} already cached`);
                    return this.getCachedTurnsInRange(startTurn, endTurn);
                }
                
                console.log(`Need to fetch turns: ${neededTurns.join(', ')}`);
                
                // Determine which snapshots to fetch
                const snapshotsToFetch = this.determineSnapshotsNeeded(Math.min(...neededTurns), Math.max(...neededTurns));
                
                // Fetch snapshots in parallel
                const snapshotPromises = snapshotsToFetch.map(turnNum =>
                    this.fetchSnapshot(episodeId, turnNum)
                );
                
                const snapshots = await Promise.allSettled(snapshotPromises);
                const successfulSnapshots = snapshots
                    .filter(result => result.status === 'fulfilled' && result.value !== null)
                    .map(result => result.value);
                
                console.log(`Fetched ${successfulSnapshots.length}/${snapshotsToFetch.length} snapshots`);
                
                // Extract needed turns from all snapshots
                const allExtractedTurns = [];
                for (const snapshot of successfulSnapshots) {
                    const extractedTurns = this.extractTurnsFromSnapshot(snapshot, neededTurns);
                    allExtractedTurns.push(...extractedTurns);
                }
                
                // Remove duplicates (same turn from multiple snapshots)
                const uniqueTurns = allExtractedTurns.filter((turn, index, arr) =>
                    arr.findIndex(t => t.turn === turn.turn) === index
                );
                
                console.log(`Successfully loaded ${uniqueTurns.length} unique turns from range ${startTurn}-${endTurn}`);
                
                // Return all turns in the requested range (cached + newly loaded)
                return this.getCachedTurnsInRange(startTurn, endTurn);
            }

            getCachedTurnsInRange(startTurn, endTurn) {
                const turns = [];
                for (let turn = startTurn; turn <= endTurn; turn++) {
                    const turnCacheKey = `${this.episodeId}_turn_${turn}`;
                    const cachedTurn = this.turnCache.get(turnCacheKey);
                    if (cachedTurn) {
                        turns.push(cachedTurn);
                    }
                }
                return turns.sort((a, b) => a.turn - b.turn);
            }

            getCachedTurn(episodeId, turnNumber) {
                const turnCacheKey = `${episodeId}_turn_${turnNumber}`;
                return this.turnCache.get(turnCacheKey) || null;
            }

            invalidateCache() {
                this.turnCache.clear();
                this.snapshotCache.clear();
                this.loadedTurnSet.clear();
            }

            getLoadedStats() {
                return {
                    cachedTurns: this.turnCache.size,
                    cachedSnapshots: this.snapshotCache.size,
                    loadedTurnCount: this.loadedTurnSet.size,
                    loadedTurns: Array.from(this.loadedTurnSet).sort((a, b) => a - b)
                };
            }
        }

        class ZorkGameViewer {
            constructor(stateUrl) {
                this.stateUrl = stateUrl;
                this.currentState = null;
                this.pollInterval = 3000; // 3 seconds
                this.mapCounter = 0; // For unique mermaid IDs
                this.isConnected = false;
                this.hasScrolled = false; // Track if user has manually scrolled
                this.userScrolledUp = false; // Track if user scrolled up from bottom
                this.lastLogCount = 0; // Track log count for new message detection
                this.scrollAnimation = null; // Track current scroll animation
                
                // Historical data management
                this.historicalDataManager = null;
                this.allLogEntries = []; // Combined current + historical
                this.displayedLogCount = 20; // Initially show 20 entries
                this.isLoadingHistorical = false;
                this.earliestLoadedTurn = null;
                
                // Episode management
                this.availableEpisodes = [];
                this.currentEpisodeId = null;
                this.isViewingHistoricalEpisode = false;
                this.originalLiveEpisodeId = null; // Track the original live episode
                
                this.startPolling();
                this.loadEpisodeIndex();
                this.setupEpisodeSelector();
            }
            
            async fetchCurrentState() {
                // Skip polling if viewing historical episode
                if (this.isViewingHistoricalEpisode) {
                    return;
                }

                try {
                    const response = await fetch(this.stateUrl);
                    if (response.ok) {
                        const newState = await response.json();
                        
                        // Check if the timestamp is fresh (within last 10 minutes)
                        const isFresh = this.isTimestampFresh(newState.metadata.timestamp);
                        
                        // Only update if state actually changed
                        if (!this.currentState ||
                            this.currentState.metadata.turn_count !== newState.metadata.turn_count ||
                            this.currentState.metadata.timestamp !== newState.metadata.timestamp) {
                            this.currentState = newState;
                            this.updateUI();
                        }
                        
                        // Set connection status based on data freshness
                        this.setConnectionStatus(isFresh);
                        
                        if (!isFresh) {
                            console.warn('Game state is stale (more than 10 minutes old)');
                        }
                    } else {
                        this.setConnectionStatus(false);
                        console.error('Failed to fetch game state:', response.status);
                    }
                } catch (error) {
                    this.setConnectionStatus(false);
                    console.error('Failed to fetch game state:', error);
                }
            }
            
            isTimestampFresh(timestamp) {
                if (!timestamp) {
                    console.warn('No timestamp found in state data');
                    return false;
                }
                
                try {
                    // Parse the timestamp (assuming ISO format)
                    const stateTime = new Date(timestamp);
                    const currentTime = new Date();
                    const diffMinutes = (currentTime - stateTime) / (1000 * 60); // Convert to minutes
                    
                    console.log(`State timestamp: ${timestamp}, Age: ${diffMinutes.toFixed(1)} minutes`);
                    
                    // Consider fresh if less than 10 minutes old
                    return diffMinutes < 10;
                } catch (error) {
                    console.error('Failed to parse timestamp:', error);
                    return false;
                }
            }
            
            setConnectionStatus(connected) {
                this.isConnected = connected;
                const indicator = document.getElementById('connection-status');
                indicator.className = `status-indicator ${connected ? 'status-connected' : 'status-disconnected'}`;
                
                if (!connected && !this.currentState) {
                    document.getElementById('episode-id').textContent = 'Connection Error';
                } else if (!connected && this.currentState) {
                    // We have data but it's stale
                    const episodeElement = document.getElementById('episode-id');
                    if (!episodeElement.textContent.includes('(Stale)')) {
                        episodeElement.textContent = this.currentState.metadata.episode_id + ' (Stale)';
                    }
                }
            }
            
            startPolling() {
                this.fetchCurrentState();
                setInterval(() => this.fetchCurrentState(), this.pollInterval);
                
                // Add scroll event listener to detect manual scrolling
                const logContainer = document.getElementById('recent-log');
                const gameLogContainer = logContainer ? logContainer.parentElement : null;
                const newMessagesIndicator = document.getElementById('new-messages-indicator');
                
                console.log('Log container:', logContainer);
                console.log('Game log container:', gameLogContainer);
                
                // Use the parent container that has overflow-y: auto
                const scrollableContainer = gameLogContainer || logContainer;
                
                if (scrollableContainer) {
                    scrollableContainer.addEventListener('scroll', () => {
                        // Check if user scrolled away from bottom (with a small tolerance)
                        const isAtBottom = scrollableContainer.scrollHeight - scrollableContainer.clientHeight <= scrollableContainer.scrollTop + 5;
                        if (!isAtBottom) {
                            this.userScrolledUp = true;
                            console.log('User scrolled up from bottom');
                        } else {
                            this.userScrolledUp = false;
                            console.log('User is at bottom');
                            // Hide indicator when user scrolls back to bottom
                            if (newMessagesIndicator) {
                                newMessagesIndicator.style.display = 'none';
                            }
                        }
                    });
                }
                
                // Add click handler for new messages indicator
                if (newMessagesIndicator) {
                    newMessagesIndicator.addEventListener('click', () => {
                        this.smoothScrollToBottom(scrollableContainer);
                        this.userScrolledUp = false;
                        newMessagesIndicator.style.display = 'none';
                    });
                }
            }
            
            updateUI() {
                if (!this.currentState) return;
                
                // Capture the original live episode ID on first load
                if (this.originalLiveEpisodeId === null && !this.isViewingHistoricalEpisode) {
                    this.originalLiveEpisodeId = this.currentState.metadata.episode_id;
                    console.log('Captured original live episode:', this.originalLiveEpisodeId);
                }
                
                this.updateGameInfo();
                this.updateMap();
                this.updateRecentLog();
                this.updateObjectives();
                this.updateKnowledgeBase();
            }
            
            updateGameInfo() {
                const meta = this.currentState.metadata;
                const current = this.currentState.current_state;
                
                // Update episode ID display - only add "Historical" suffix if we're actually viewing a historical episode
                const episodeIdElement = document.getElementById('episode-id');
                if (this.isViewingHistoricalEpisode) {
                    episodeIdElement.textContent = `${meta.episode_id} (Historical)`;
                    episodeIdElement.style.color = '#ff9800'; // Orange for historical
                } else {
                    episodeIdElement.textContent = meta.episode_id;
                    episodeIdElement.style.color = '#007bff'; // Blue for live
                }
                document.getElementById('turn-count').textContent = meta.turn_count;
                document.getElementById('max-turns').textContent = meta.max_turns;
                document.getElementById('score').textContent = meta.score;
                document.getElementById('location').textContent = current.location;
                document.getElementById('inventory').textContent = 
                    current.inventory.length > 0 ? current.inventory.join(', ') : 'Empty';
                document.getElementById('death-count').textContent = 
                    current.death_count || 0;
                
                // Update FAQ model information
                if (meta.models) {
                    document.getElementById('faq-agent-model').textContent = meta.models.agent || 'Unknown';
                    document.getElementById('faq-critic-model').textContent = meta.models.critic || 'Unknown';
                    document.getElementById('faq-extractor-model').textContent = meta.models.extractor || 'Unknown';
                    document.getElementById('faq-knowledge-model').textContent = meta.models.knowledge_base || 'Unknown';
                } else {
                    document.getElementById('faq-agent-model').textContent = 'Not available';
                    document.getElementById('faq-critic-model').textContent = 'Not available';
                    document.getElementById('faq-extractor-model').textContent = 'Not available';
                    document.getElementById('faq-knowledge-model').textContent = 'Not available';
                }
            }
            
            async updateMap() {
                const mapData = this.currentState.map;
                const mapContainer = document.getElementById('map-diagram');
                const mapStats = document.getElementById('map-stats');
                
                if (!mapContainer) {
                    console.error('Map container not found');
                    return;
                }
                
                if (!mapData || !mapData.mermaid_diagram) {
                    mapContainer.innerHTML = '<p class="error-message">No map data available</p>';
                    return;
                }

                await this.renderMapToContainer('map-diagram', 'map-stats');
            }
            
            async renderMapToContainer(diagramElementId, statsElementId) {
                const mapData = this.currentState.map;
                const mapContainer = document.getElementById(diagramElementId);
                const mapStats = document.getElementById(statsElementId);
                
                if (!mapContainer) {
                    console.error('Map container not found:', diagramElementId);
                    return;
                }
                
                if (!mapData || !mapData.mermaid_diagram) {
                    mapContainer.innerHTML = '<p class="error-message">No map data available</p>';
                    return;
                }

                try {
                    // Create unique ID for this map render
                    this.mapCounter++;
                    const mapId = `mermaid-map-${this.mapCounter}`;
                    
                    console.log('Rendering map with ID:', mapId);
                    console.log('Mermaid code:', mapData.mermaid_diagram);
                    
                    // Highlight current room in the diagram
                    let mermaidCode = mapData.mermaid_diagram;
                    
                    // Add styling to highlight current room
                    if (mapData.current_room) {
                        console.log('Current room to highlight:', mapData.current_room);
                        mermaidCode += `\n    classDef currentRoom fill:#ffeb3b,stroke:#f57f17,stroke-width:3px`;
                        
                        // Find the node ID for current room and apply class
                        const lines = mermaidCode.split('\n');
                        let foundMatch = false;
                        for (let i = 0; i < lines.length; i++) {
                            console.log('Checking line:', lines[i]);
                            if (lines[i].includes(`"${mapData.current_room}"`)) {
                                console.log('Found matching line:', lines[i]);
                                const nodeMatch = lines[i].match(/^\s*(\w+)\[/);
                                if (nodeMatch) {
                                    console.log('Applying class to node:', nodeMatch[1]);
                                    mermaidCode += `\n    class ${nodeMatch[1]} currentRoom`;
                                    foundMatch = true;
                                    break;
                                }
                            }
                        }
                        if (!foundMatch) {
                            console.warn('Could not find current room in mermaid diagram:', mapData.current_room);
                        }
                    }
                    
                    // Render the mermaid diagram directly to the container
                    const { svg } = await mermaid.render(mapId, mermaidCode);
                    
                    // Set the SVG directly to the container
                    mapContainer.innerHTML = svg;
                    
                    // Update map stats
                    if (mapStats) {
                        mapStats.innerHTML = `
                            <strong>Map Stats:</strong> 
                            ${mapData.total_rooms} rooms, 
                            ${mapData.total_connections} connections
                        `;
                    }
                    
                } catch (error) {
                    console.error('Failed to render map:', error);
                    mapContainer.innerHTML = `<p class="error-message">Error rendering map: ${error.message}</p>`;
                }
            }
            
            updateRecentLog() {
                const logContainer = document.getElementById('recent-log');
                const newMessagesIndicator = document.getElementById('new-messages-indicator');
                
                // Get current logs from state
                const currentLogs = this.currentState.recent_log || [];
                
                if (currentLogs.length === 0) {
                    logContainer.innerHTML = '<div class="log-entry">No recent actions</div>';
                    return;
                }
                
                // Merge with any loaded historical data
                this.mergeLogEntries(currentLogs);
                
                // Display the requested number of entries
                const logsToDisplay = this.allLogEntries.slice(-this.displayedLogCount);
                
                // Check if there are new messages
                const currentLogCount = currentLogs.length;
                const hasNewMessages = this.lastLogCount && currentLogCount > this.lastLogCount;
                this.lastLogCount = currentLogCount;
                
                // Add "Load Earlier Turns" button if there might be more data
                let loadEarlierButton = '';
                if (this.canLoadEarlierTurns()) {
                    const stats = this.historicalDataManager ? this.historicalDataManager.getLoadedStats() : null;
                    const statsText = stats ? ` (${stats.loadedTurnCount} cached)` : '';
                    
                    loadEarlierButton = `
                        <div class="load-earlier-container">
                            <button id="load-earlier-btn" class="load-earlier-btn" ${this.isLoadingHistorical ? 'disabled' : ''}>
                                ${this.isLoadingHistorical ? '<span class="loading-spinner"></span>Loading...' : 'Load Earlier Turns'}
                            </button>
                            ${stats ? `<div class="historical-stats">Cache: ${stats.cachedTurns}/${stats.loadedTurnCount} turns${statsText}</div>` : ''}
                        </div>
                    `;
                }

                // Render log entries
                const logHtml = loadEarlierButton + logsToDisplay.map(entry => {
                    return this.renderLogEntry(entry);
                }).join('');

                logContainer.innerHTML = logHtml;

                // Add event listener for load earlier button
                const loadEarlierBtn = document.getElementById('load-earlier-btn');
                if (loadEarlierBtn) {
                    loadEarlierBtn.addEventListener('click', () => this.loadEarlierTurns());
                }

                // Auto-scroll logic (same as before)
                if (!this.userScrolledUp) {
                    console.log('Auto-scrolling to bottom smoothly');
                    setTimeout(() => {
                        const gameLogContainer = logContainer ? logContainer.parentElement : null;
                        const scrollableContainer = gameLogContainer || logContainer;
                        
                        if (this.scrollAnimation) {
                            console.log('Animation already running, will restart after completion');
                            cancelAnimationFrame(this.scrollAnimation);
                            this.scrollAnimation = null;
                            setTimeout(() => {
                                this.smoothScrollToBottom(scrollableContainer);
                            }, 100);
                        } else {
                            this.smoothScrollToBottom(scrollableContainer);
                        }
                        
                        if (newMessagesIndicator) {
                            newMessagesIndicator.style.display = 'none';
                        }
                    }, 50);
                } else if (hasNewMessages && this.userScrolledUp) {
                    console.log('User scrolled up, showing new messages indicator');
                    if (newMessagesIndicator) {
                        newMessagesIndicator.style.display = 'block';
                    }
                }
                
                this.hasScrolled = true;
            }
            
            updateObjectives() {
                const objectivesContainer = document.getElementById('objectives-content');
                const objectivesHeader = document.getElementById('objectives-header');
                const currentState = this.currentState.current_state;
                const objectives = currentState ? currentState.discovered_objectives : null;
                
                if (!objectives || objectives.length === 0) {
                    objectivesContainer.innerHTML = '<p style="color: #666; font-style: italic;">No current objectives</p>';
                    objectivesHeader.textContent = 'Current Objectives';
                    return;
                }
                
                // Update header with count
                objectivesHeader.textContent = `Current Objectives (${objectives.length})`;
                
                try {
                    // Create a nicely formatted list of objectives
                    let objectivesHtml = '<ul class="objectives-list">';
                    
                    objectives.forEach((objective, index) => {
                        // Clean up the objective text by removing brackets if present
                        let cleanObjective = objective.trim();
                        if (cleanObjective.startsWith('[') && cleanObjective.includes(']')) {
                            cleanObjective = cleanObjective.substring(1);
                            const endBracket = cleanObjective.indexOf(']');
                            if (endBracket !== -1) {
                                const title = cleanObjective.substring(0, endBracket);
                                let description = cleanObjective.substring(endBracket + 1).trim();
                                
                                // Remove leading parenthesis and trailing parenthesis if present
                                if (description.startsWith('(') && description.endsWith(')')) {
                                    description = description.substring(1, description.length - 1);
                                }
                                
                                cleanObjective = `<strong>${this.escapeHtml(title)}</strong>`;
                                if (description) {
                                    cleanObjective += `<br><small style="color: #666; line-height: 1.3;">${this.escapeHtml(description)}</small>`;
                                }
                            }
                        } else {
                            cleanObjective = this.escapeHtml(cleanObjective);
                        }
                        
                        objectivesHtml += `<li class="objective-item">${cleanObjective}</li>`;
                    });
                    
                    objectivesHtml += '</ul>';
                    objectivesContainer.innerHTML = objectivesHtml;
                    
                } catch (error) {
                    console.error('Failed to render objectives:', error);
                    objectivesContainer.innerHTML = `<p class="error-message">Error rendering objectives: ${error.message}</p>`;
                }
            }
            
            updateKnowledgeBase() {
                const knowledgeContainer = document.getElementById('knowledge-content');
                const knowledge = this.currentState.knowledge_base;
                
                if (!knowledge || !knowledge.content) {
                    knowledgeContainer.innerHTML = '<p class="error-message">No knowledge base available</p>';
                    return;
                }
                
                try {
                    // Configure marked.js for better rendering
                    marked.setOptions({
                        breaks: true,        // Convert line breaks to <br>
                        gfm: true,          // GitHub Flavored Markdown
                        headerIds: false,   // Don't add IDs to headers
                        mangle: false       // Don't mangle email addresses
                    });
                    
                    // Convert markdown to HTML using marked.js
                    const htmlContent = marked.parse(knowledge.content);
                    
                    knowledgeContainer.innerHTML = htmlContent;
                    
                } catch (error) {
                    console.error('Failed to render knowledge base markdown:', error);
                    knowledgeContainer.innerHTML = `<p class="error-message">Error rendering knowledge base: ${error.message}</p>`;
                }
            }
            
            smoothScrollToBottom(container) {
                console.log('smoothScrollToBottom called');
                console.log('Container:', container);
                console.log('Container scrollTop:', container.scrollTop);
                console.log('Container scrollHeight:', container.scrollHeight);
                console.log('Container clientHeight:', container.clientHeight);
                
                // Cancel any existing animation
                if (this.scrollAnimation) {
                    cancelAnimationFrame(this.scrollAnimation);
                }
                
                const startPosition = container.scrollTop;
                const targetPosition = container.scrollHeight - container.clientHeight;
                const distance = targetPosition - startPosition;
                const duration = 800; // 800ms animation
                
                console.log('Start position:', startPosition);
                console.log('Target position:', targetPosition);
                console.log('Distance to scroll:', distance);
                
                // If already at bottom or no distance to scroll, return early
                if (distance <= 5) { // Small tolerance for "close enough"
                    console.log('Already at bottom or no distance to scroll');
                    return;
                }
                
                const startTime = performance.now();
                
                // Easing function for smooth animation (ease-out)
                const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
                
                const animateScroll = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Apply easing function
                    const easedProgress = easeOutCubic(progress);
                    
                    // Recalculate target in case content changed during animation
                    const currentTarget = container.scrollHeight - container.clientHeight;
                    
                    // If content has grown significantly, adjust our animation
                    if (currentTarget > targetPosition + 50) {
                        console.log('Content grew during animation, adjusting target');
                        // Smoothly transition to the new target
                        const adjustedTarget = currentTarget;
                        const currentPos = container.scrollTop;
                        const remainingDistance = adjustedTarget - currentPos;
                        const adjustedPosition = currentPos + (remainingDistance * easedProgress);
                        container.scrollTop = Math.min(adjustedPosition, adjustedTarget);
                    } else {
                        // Normal animation
                        const currentPosition = startPosition + (distance * easedProgress);
                        container.scrollTop = Math.min(currentPosition, currentTarget);
                    }
                    
                    if (progress === 0 || progress === 1 || elapsed % 200 < 16) {
                        console.log(`Animation progress: ${(progress * 100).toFixed(1)}%, scrollTop: ${container.scrollTop}, target: ${currentTarget}`);
                    }
                    
                    // Continue animation if not complete
                    if (progress < 1) {
                        this.scrollAnimation = requestAnimationFrame(animateScroll);
                    } else {
                        console.log('Animation complete');
                        this.scrollAnimation = null;
                        
                        // Final check - make sure we're actually at the bottom
                        const finalTarget = container.scrollHeight - container.clientHeight;
                        if (Math.abs(container.scrollTop - finalTarget) > 5) {
                            console.log('Final position adjustment needed');
                            container.scrollTop = finalTarget;
                        }
                    }
                };
                
                // Start the animation
                this.scrollAnimation = requestAnimationFrame(animateScroll);
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // Historical data management methods
            mergeLogEntries(currentLogs) {
                // Get any cached historical turns
                const historicalTurns = [];
                if (this.historicalDataManager) {
                    const stats = this.historicalDataManager.getLoadedStats();
                    for (const turn of stats.loadedTurns) {
                        const cachedTurn = this.historicalDataManager.getCachedTurn(this.currentState.metadata.episode_id, turn);
                        if (cachedTurn) {
                            historicalTurns.push(cachedTurn);
                        }
                    }
                }
                
                // Combine historical and current logs, removing duplicates
                const allLogs = [...historicalTurns, ...currentLogs];
                
                // Remove duplicates by turn number (keep the most recent version)
                const uniqueLogs = allLogs.filter((log, index, arr) =>
                    arr.findIndex(l => l.turn === log.turn) === index
                );
                
                // Sort by turn number
                this.allLogEntries = uniqueLogs.sort((a, b) => a.turn - b.turn);
                
                console.log(`Merged logs: ${historicalTurns.length} historical + ${currentLogs.length} current = ${this.allLogEntries.length} total`);
            }

            canLoadEarlierTurns() {
                // Check if we have an episode ID and turn count to potentially load earlier data
                if (!this.currentState || !this.currentState.metadata) {
                    return false;
                }
                
                const currentTurn = this.currentState.metadata.turn_count;
                const episodeId = this.currentState.metadata.episode_id;
                
                // Only show load button if we're past turn 20 and have episode info
                return currentTurn > 20 && episodeId;
            }

            async loadEarlierTurns() {
                if (this.isLoadingHistorical) {
                    return;
                }

                this.isLoadingHistorical = true;
                
                // Update button state immediately
                this.updateLoadEarlierButton();
                
                try {
                    // Initialize historical data manager if needed
                    if (!this.historicalDataManager) {
                        const episodeId = this.currentState.metadata.episode_id;
                        this.historicalDataManager = new HistoricalDataManager('./zorkgpt', episodeId);
                    }

                    // Determine range to load (20 turns before earliest loaded)
                    const currentTurn = this.currentState.metadata.turn_count;
                    let startTurn = Math.max(1, currentTurn - this.displayedLogCount - 20);
                    let endTurn = Math.max(1, currentTurn - this.displayedLogCount);

                    if (this.earliestLoadedTurn !== null) {
                        endTurn = this.earliestLoadedTurn - 1;
                        startTurn = Math.max(1, endTurn - 19);
                    }

                    console.log(`Loading historical turns ${startTurn}-${endTurn}`);

                    // Load the historical data
                    const historicalTurns = await this.historicalDataManager.loadTurnRange(
                        this.currentState.metadata.episode_id,
                        startTurn,
                        endTurn
                    );

                    if (historicalTurns.length > 0) {
                        // Update earliest loaded turn
                        this.earliestLoadedTurn = Math.min(...historicalTurns.map(t => t.turn));
                        
                        // Increase displayed count
                        this.displayedLogCount += 20;
                        
                        console.log(`Loaded ${historicalTurns.length} historical turns`);
                    } else {
                        console.log('No historical turns found in range');
                    }

                } catch (error) {
                    console.error('Failed to load historical turns:', error);
                } finally {
                    this.isLoadingHistorical = false;
                    
                    // Always refresh the log display to update button state
                    this.updateRecentLog();
                }
            }

            updateLoadEarlierButton() {
                const loadEarlierBtn = document.getElementById('load-earlier-btn');
                if (!loadEarlierBtn) return;

                const stats = this.historicalDataManager ? this.historicalDataManager.getLoadedStats() : null;
                
                if (this.isLoadingHistorical) {
                    loadEarlierBtn.disabled = true;
                    loadEarlierBtn.innerHTML = '<span class="loading-spinner"></span>Loading...';
                } else {
                    loadEarlierBtn.disabled = false;
                    loadEarlierBtn.innerHTML = 'Load Earlier Turns';
                }

                // Update stats display
                const statsElement = loadEarlierBtn.parentElement.querySelector('.historical-stats');
                if (statsElement && stats) {
                    const statsText = ` (${stats.loadedTurnCount} cached)`;
                    statsElement.textContent = `Cache: ${stats.cachedTurns}/${stats.loadedTurnCount} turns${statsText}`;
                }
            }

            renderLogEntry(entry) {
                const isHistorical = entry._isHistorical || false;
                const historicalClass = isHistorical ? ' historical-log-entry' : '';
                const historicalIndicator = isHistorical ? '<span class="historical-indicator">(Historical)</span>' : '';

                let html = `<div class="log-entry${historicalClass}">`;
                
                // Turn header
                html += `<div class="log-turn-header">Turn ${entry.turn}${historicalIndicator}</div>`;
                
                // Thinking section
                if (entry.reasoning) {
                    html += `<div class="log-thinking">üí≠ Thinking: ${this.escapeHtml(entry.reasoning)}</div>`;
                }
                
                // Proposed action
                if (entry.action) {
                    html += `<div class="log-proposed-action">üéØ Proposed Action: ${this.escapeHtml(entry.action)}</div>`;
                }
                
                // Rejected actions section (if any)
                if (entry.rejected_actions && entry.rejected_actions.length > 0) {
                    html += `<div class="log-critic">üö´ Rejected Actions:</div>`;
                    entry.rejected_actions.forEach((rejected, index) => {
                        html += `<div class="log-critic" style="margin-left: 20px;">${index + 1}. "${this.escapeHtml(rejected.action)}" (Score: ${rejected.score.toFixed(2)})<br>"${this.escapeHtml(rejected.justification)}"</div>`;
                    });
                }
                
                // Final critic evaluation
                if (entry.critic_justification) {
                    let status;
                    const score = entry.critic_score !== undefined ? entry.critic_score.toFixed(2) : 'N/A';

                    // Determine status based on score and override
                    if (entry.was_overridden) {
                        // Rejection was overridden - show this clearly
                        status = '<span style="color: #ff9800;">Action rejected BUT OVERRIDDEN</span>';
                    } else if (entry.critic_score !== undefined && entry.critic_score < 0) {
                        status = 'Action rejected';
                    } else {
                        status = 'Action approved';
                    }

                    html += `<div class="log-critic">‚öñÔ∏è Final Critic Evaluation: ${status} (Score: ${score})<br>"${this.escapeHtml(entry.critic_justification)}"</div>`;

                    // If overridden, show override reason if available
                    if (entry.was_overridden && entry.override_reason && entry.override_reason.trim()) {
                        html += `<div class="log-critic" style="margin-left: 20px; color: #ff9800;">‚Ü≥ Override reason: ${this.escapeHtml(entry.override_reason)}</div>`;
                    }
                }
                
                // Action taken
                if (entry.action) {
                    html += `<div class="log-action-taken">‚úÖ Action Taken: ${this.escapeHtml(entry.action)}</div>`;
                }
                
                // Game response
                if (entry.zork_response) {
                    html += `<div class="log-response">üéÆ Game Response:<br>${this.escapeHtml(entry.zork_response).replace(/\n/g, '<br>')}</div>`;
                }
                
                html += '</div>';
                return html;
            }

            // Episode management methods
            async loadEpisodeIndex() {
                try {
                    const response = await fetch('./zorkgpt/episodes.json');
                    if (response.ok) {
                        const episodeIndex = await response.json();
                        this.availableEpisodes = episodeIndex.episodes || [];
                        console.log(`Loaded ${this.availableEpisodes.length} episodes from index`);
                        this.updateEpisodeSelector();
                    } else {
                        console.warn('Episode index not found, episode selection disabled');
                    }
                } catch (error) {
                    console.warn('Failed to load episode index:', error);
                }
            }

            setupEpisodeSelector() {
                const episodeIdElement = document.getElementById('episode-id');
                if (episodeIdElement) {
                    episodeIdElement.addEventListener('click', () => {
                        if (this.availableEpisodes.length > 0) {
                            this.showEpisodeSelector();
                        }
                    });
                }

                // Close episode selector when clicking outside
                document.addEventListener('click', (event) => {
                    const episodeSelector = document.getElementById('episode-selector');
                    const episodeIdElement = document.getElementById('episode-id');
                    
                    if (episodeSelector &&
                        !episodeSelector.contains(event.target) &&
                        !episodeIdElement.contains(event.target)) {
                        this.hideEpisodeSelector();
                    }
                });
            }

            updateEpisodeSelector() {
                const episodeList = document.getElementById('episode-list');
                if (!episodeList || this.availableEpisodes.length === 0) {
                    return;
                }

                let html = '';
                
                for (const episode of this.availableEpisodes) {
                    // Highlight the episode we're currently viewing (either live or historical)
                    const isCurrentlyViewing = this.currentState &&
                        this.currentState.metadata.episode_id === episode.episode_id;
                    
                    const status = this.getEpisodeStatus(episode); //not implementing this at this point
                    const statusClass = `episode-status-${status.toLowerCase()}`;
                    
                    html += `
                        <div class="episode-item ${isCurrentlyViewing ? 'current' : ''}"
                             onclick="window.zorkViewer.selectEpisode('${this.escapeHtml(episode.episode_id)}')">
                            <div class="episode-item-header">
                                <div class="episode-item-id">${this.escapeHtml(episode.episode_id)}</div>
                            </div>
                            <div class="episode-item-stats">
                                <div class="episode-item-stat">
                                    <span>üéØ</span>
                                    <span>${this.escapeHtml(String(episode.total_turns))} turns</span>
                                </div>
                                <div class="episode-item-stat">
                                    <span>‚≠ê</span>
                                    <span>${this.escapeHtml(String(episode.final_score))} pts</span>
                                </div>
                                <div class="episode-item-stat">
                                    <span>üíÄ</span>
                                    <span>${this.escapeHtml(String(episode.death_count))}</span>
                                </div>
                                <div class="episode-item-stat">
                                    <span>üìÖ</span>
                                    <span>${this.escapeHtml(this.formatDate(episode.start_time))}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }

                episodeList.innerHTML = html;
            }

            getEpisodeStatus(episode) {
                if (episode.game_over) {
                    return episode.death_count > 0 ? 'Died' : 'Completed';
                }
                return 'Ongoing';
            }

            formatDate(dateString) {
                try {
                    const date = new Date(dateString);
                    return date.toLocaleDateString();
                } catch (error) {
                    return dateString.split('T')[0]; // Fallback to date part
                }
            }

            showEpisodeSelector() {
                const episodeSelector = document.getElementById('episode-selector');
                if (episodeSelector) {
                    episodeSelector.style.display = 'block';
                    this.updateEpisodeSelector(); // Refresh the list
                }
            }

            hideEpisodeSelector() {
                const episodeSelector = document.getElementById('episode-selector');
                if (episodeSelector) {
                    episodeSelector.style.display = 'none';
                }
            }

            async selectEpisode(episodeId) {
                console.log(`Selecting episode: ${episodeId}`);
                this.hideEpisodeSelector();

                // Check if this is the original live episode (the one that was running when page loaded)
                const isOriginalLiveEpisode = this.originalLiveEpisodeId && 
                    this.originalLiveEpisodeId === episodeId;

                if (isOriginalLiveEpisode && !this.isViewingHistoricalEpisode) {
                    console.log('Already viewing current live episode');
                    return;
                }

                // Find episode info
                const episodeInfo = this.availableEpisodes.find(ep => ep.episode_id === episodeId);
                if (!episodeInfo) {
                    console.error('Episode not found:', episodeId);
                    return;
                }

                try {
                    // Determine if we should be in historical mode
                    const shouldBeHistorical = !isOriginalLiveEpisode;
                    this.isViewingHistoricalEpisode = shouldBeHistorical;
                    this.currentEpisodeId = episodeId;

                    console.log(`Episode ${episodeId}: isOriginalLive=${isOriginalLiveEpisode}, shouldBeHistorical=${shouldBeHistorical}`);

                    if (this.isViewingHistoricalEpisode) {
                        // Load the latest snapshot for this episode
                        await this.loadHistoricalEpisode(episodeInfo);
                    } else {
                        // Switch back to live mode
                        this.resumeLiveMode();
                    }

                } catch (error) {
                    console.error('Failed to switch episode:', error);
                    // Reset to live mode on error
                    this.isViewingHistoricalEpisode = false;
                    this.currentEpisodeId = null;
                }
            }

            async loadHistoricalEpisode(episodeInfo) {
                console.log('Loading historical episode:', episodeInfo.episode_id);

                try {
                    // Load the final snapshot for this episode
                    const snapshotUrl = `./zorkgpt/snapshots/${episodeInfo.episode_id}/turn_${episodeInfo.last_turn}.json`;
                    const response = await fetch(snapshotUrl);

                    if (!response.ok) {
                        throw new Error(`Failed to load episode snapshot: ${response.status}`);
                    }

                    const historicalState = await response.json();
                    
                    // Update current state with historical data
                    this.currentState = historicalState;
                    
                    // Reset historical data manager for this episode
                    this.historicalDataManager = new HistoricalDataManager('./zorkgpt', episodeInfo.episode_id);
                    this.allLogEntries = [];
                    this.displayedLogCount = 20;
                    this.earliestLoadedTurn = null;
                    
                    // Update UI
                    this.updateUI();

                    console.log('Historical episode loaded successfully');

                } catch (error) {
                    console.error('Failed to load historical episode:', error);
                    throw error;
                }
            }

            resumeLiveMode() {
                console.log('Resuming live mode');
                
                this.isViewingHistoricalEpisode = false;
                this.currentEpisodeId = null;
                
                // Reset historical data
                this.historicalDataManager = null;
                this.allLogEntries = [];
                this.displayedLogCount = 20;
                this.earliestLoadedTurn = null;
                
                // Reset episode ID display style and text
                const episodeIdElement = document.getElementById('episode-id');
                if (episodeIdElement) {
                    episodeIdElement.style.color = '#007bff'; // Back to blue
                    episodeIdElement.textContent = 'Loading...'; // Reset text, will be updated by fetchCurrentState
                }
                
                // Force refresh of current state
                this.fetchCurrentState();
            }
        }

        // Episode Selector Functions
        function hideEpisodeSelector() {
            if (window.zorkViewer) {
                window.zorkViewer.hideEpisodeSelector();
            }
        }

        // FAQ Modal Functions
        function showFAQ() {
            document.getElementById('faq-modal').style.display = 'block';
        }
        
        function hideFAQ() {
            document.getElementById('faq-modal').style.display = 'none';
        }

        // Map Modal Functions
        function showExpandedMap() {
            document.getElementById('map-modal').style.display = 'block';
            // Re-render the map in the expanded view
            if (window.zorkViewer && window.zorkViewer.currentState) {
                window.zorkViewer.renderMapToContainer('map-diagram-expanded', 'map-stats-expanded');
            }
        }
        
        function hideExpandedMap() {
            document.getElementById('map-modal').style.display = 'none';
        }

        // Close modal when clicking outside of it
        document.addEventListener('click', function(event) {
            const faqModal = document.getElementById('faq-modal');
            const mapModal = document.getElementById('map-modal');
            if (event.target === faqModal) {
                hideFAQ();
            }
            if (event.target === mapModal) {
                hideExpandedMap();
            }
        });
        
        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                hideFAQ();
                hideExpandedMap();
            }
        });

        // Initialize the viewer
        // Check which state file is available
        async function initializeViewer() {
            try {
                // Try live file first (works for both local and S3 deployment)
                const response = await fetch('./zorkgpt/current_state.json');
                if (response.ok) {
                    console.log('Using current_state.json (live)');
                    return new ZorkGameViewer('./zorkgpt/current_state.json');
                }
            } catch (e) {
                console.log('current_state.json not available');
            }
            
            try {
                // Fall back to test file (for local development)
                const testResponse = await fetch('./test_current_state.json');
                if (testResponse.ok) {
                    console.log('Using test_current_state.json (fallback)');
                    return new ZorkGameViewer('./test_current_state.json');
                }
            } catch (e) {
                console.log('test_current_state.json not available');
            }
            
            // Show error if no files available
            document.getElementById('episode-id').textContent = 'No state file found';
            document.getElementById('map-diagram').innerHTML = '<p class="error-message">No state files available. Run ZorkGPT with S3 configured or test_state_export.py for local testing.</p>';
            return null;
        }
        
        // Initialize the viewer
        initializeViewer().then(viewer => {
            if (viewer) {
                console.log('ZorkGPT Live Viewer initialized successfully');
                // Store globally so map modal can access it
                window.zorkViewer = viewer;
            }
        });
    </script>
</body>
</html> 
