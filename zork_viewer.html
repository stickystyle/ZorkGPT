<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZorkGPT Live Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f5f5f5;
        }
        
        .game-container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            grid-template-rows: auto 1fr;
            gap: 20px;
            padding: 20px;
            height: 100vh;
            box-sizing: border-box;
        }
        
        /* Mobile responsive layout */
        @media (max-width: 768px) {
            .game-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto auto;
                height: auto;
                min-height: 100vh;
                padding: 10px;
                gap: 15px;
            }
            
            .game-info {
                grid-column: 1;
                grid-row: 1;
            }
            
            .game-log {
                grid-column: 1;
                grid-row: 2;
                max-height: 500px;
                overflow-y: auto;
            }
            
            .map-container {
                grid-column: 1;
                grid-row: 3;
                max-height: 400px;
                overflow-y: auto;
            }
            
            .knowledge-section {
                grid-column: 1;
                grid-row: 4;
                max-height: 400px;
                overflow-y: auto;
            }
        }
        
        /* Tablet responsive layout */
        @media (max-width: 1024px) and (min-width: 769px) {
            .game-container {
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto 1fr 1fr;
                gap: 15px;
                padding: 15px;
            }
            
            .game-info {
                grid-column: 1 / -1;
                grid-row: 1;
            }
            
            .knowledge-section {
                grid-column: 1;
                grid-row: 2;
            }
            
            .game-log {
                grid-column: 2;
                grid-row: 2;
            }
            
            .map-container {
                grid-column: 1 / -1;
                grid-row: 3;
                max-height: 400px;
                overflow-y: auto;
            }
        }
        
        .game-info {
            grid-column: 1 / -1;
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        /* Header styling */
        .header-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .header-links {
            display: flex;
            gap: 15px;
        }
        
        /* Mobile responsive header and info grid */
        @media (max-width: 768px) {
            .header-container {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
                margin-bottom: 10px;
            }
            
            .header-links {
                gap: 10px;
            }
            
            .info-grid {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 10px;
                margin-top: 10px;
            }
        }
        
        .info-item {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 8px;
            border-left: 4px solid #007bff;
        }
        
        .map-container {
            background: white;
            border-radius: 12px;
            padding: 20px;
            overflow: auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .game-log {
            background: #1e1e1e;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            padding: 20px;
            border-radius: 12px;
            overflow-y: auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            position: relative;
            text-align: left;
        }
        
        .knowledge-section {
            background: white;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow-y: auto;
        }
        
        .objectives-list {
            margin: 0 0 20px 0;
            padding: 0;
            list-style: none;
        }
        
        .objective-item {
            background: #f8f9fa;
            margin: 8px 0;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #28a745;
            font-size: 14px;
            line-height: 1.4;
        }
        
        .objective-item:nth-child(even) {
            background: #e9ecef;
        }
        
        .objective-item strong {
            display: block;
            margin-bottom: 4px;
            color: #2c5530;
        }
        
        .objectives-divider {
            border: none;
            height: 2px;
            background: linear-gradient(to right, #dee2e6, #6c757d, #dee2e6);
            margin: 20px 0;
            border-radius: 1px;
        }
        
        .current-room {
            background: #ffeb3b;
            padding: 4px 8px;
            border-radius: 6px;
            font-weight: bold;
            color: #333;
        }
        
        .log-entry {
            margin-bottom: 20px;
            border-bottom: 1px solid #333;
            padding-bottom: 15px;
        }
        
        .log-turn-header {
            color: #00bfff;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        
        .log-thinking {
            color: #ffeb3b;
            font-style: italic;
            margin: 8px 0;
            padding: 8px 12px;
            background: rgba(255, 235, 59, 0.1);
            border-left: 3px solid #ffeb3b;
            border-radius: 4px;
            font-size: 0.9em;
            line-height: 1.4;
        }
        
        .log-proposed-action {
            color: #87ceeb;
            margin: 8px 0;
            padding: 6px 12px;
            background: rgba(135, 206, 235, 0.1);
            border-left: 3px solid #87ceeb;
            border-radius: 4px;
        }
        
        .log-critic {
            color: #ffa500;
            margin: 8px 0;
            padding: 6px 12px;
            background: rgba(255, 165, 0, 0.1);
            border-left: 3px solid #ffa500;
            border-radius: 4px;
            font-size: 0.9em;
        }
        
        .log-action-taken {
            color: #98fb98;
            font-weight: bold;
            margin: 8px 0;
            padding: 6px 12px;
            background: rgba(152, 251, 152, 0.1);
            border-left: 3px solid #98fb98;
            border-radius: 4px;
        }
        
        .log-response {
            color: #90ee90;
            line-height: 1.4;
            margin: 8px 0;
            padding: 8px 12px;
            background: rgba(144, 238, 144, 0.05);
            border-radius: 4px;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-connected {
            background-color: #28a745;
        }
        
        .status-disconnected {
            background-color: #dc3545;
        }
        
        .map-stats {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 14px;
            color: #666;
        }
        
        h1, h2, h3 {
            margin-top: 0;
            color: #333;
        }
        
        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 10px;
            border-radius: 6px;
            margin: 10px 0;
        }
        
        .loading {
            text-align: center;
            color: #666;
            font-style: italic;
        }
        
        /* Override any inherited centering */
        .game-log .loading {
            text-align: center !important;
        }
        
        .knowledge-section .loading {
            text-align: center !important;
        }
        
        /* Fix text alignment issues */
        .game-log * {
            text-align: left !important;
        }
        
        .knowledge-section {
            text-align: left !important;
        }
        
        .knowledge-section * {
            text-align: left !important;
        }
        
        .knowledge-section h1 {
            color: #333 !important;
            margin: 20px 0 15px 0 !important;
            font-size: 20px !important;
            text-align: left !important;
            font-weight: bold !important;
        }
        
        .knowledge-section h2 {
            color: #333 !important;
            margin: 18px 0 12px 0 !important;
            font-size: 18px !important;
            text-align: left !important;
            font-weight: bold !important;
        }
        
        .knowledge-section h3 {
            color: #444 !important;
            margin: 15px 0 10px 0 !important;
            font-size: 16px !important;
            text-align: left !important;
            font-weight: bold !important;
        }
        
        .knowledge-section h4 {
            color: #555 !important;
            margin: 12px 0 8px 0 !important;
            font-size: 14px !important;
            text-align: left !important;
            font-weight: bold !important;
        }
        
        .knowledge-section ul {
            margin: 10px 0 !important;
            padding-left: 20px !important;
            text-align: left !important;
        }
        
        .knowledge-section li {
            margin: 5px 0 !important;
            line-height: 1.4 !important;
            text-align: left !important;
        }
        
        .knowledge-section p {
            margin: 10px 0 !important;
            line-height: 1.5 !important;
            text-align: left !important;
        }
        
        .knowledge-section strong {
            font-weight: bold !important;
        }
        
        .knowledge-section em {
            font-style: italic !important;
        }
        
        .knowledge-section code {
            background-color: #f4f4f4 !important;
            padding: 2px 4px !important;
            border-radius: 3px !important;
            font-family: 'Courier New', monospace !important;
            font-size: 90% !important;
        }
        
        .knowledge-section pre {
            background-color: #f8f8f8 !important;
            padding: 10px !important;
            border-radius: 5px !important;
            overflow-x: auto !important;
            margin: 10px 0 !important;
        }
        
        .knowledge-section blockquote {
            border-left: 4px solid #ddd !important;
            margin: 10px 0 !important;
            padding-left: 15px !important;
            color: #666 !important;
            font-style: italic !important;
        }
        
        .knowledge-section table {
            border-collapse: collapse !important;
            width: 100% !important;
            margin: 10px 0 !important;
        }
        
        .knowledge-section th,
        .knowledge-section td {
            border: 1px solid #ddd !important;
            padding: 8px !important;
            text-align: left !important;
        }
        
        .knowledge-section th {
            background-color: #f2f2f2 !important;
            font-weight: bold !important;
        }
        
        /* New messages indicator */
        .new-messages-indicator {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: #007bff;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
        }
        
        .new-messages-indicator:hover {
            background: #0056b3;
        }
        
        /* FAQ Modal styling */
        .faq-modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        .faq-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        /* Map Modal styling */
        .map-modal-content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 12px;
            max-width: 90vw;
            max-height: 90vh;
            width: 1200px;
            height: 800px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
        }
        
        .map-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-shrink: 0;
        }
        
        .map-modal-body {
            flex: 1;
            overflow: auto;
            display: flex;
            flex-direction: column;
        }
        
        #map-diagram-expanded {
            flex: 1;
            min-height: 500px;
            overflow: auto;
        }
        
        #map-stats-expanded {
            margin-top: 15px;
            flex-shrink: 0;
        }
        
        /* Mobile responsive FAQ modal */
        @media (max-width: 768px) {
            .faq-modal-content {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                transform: none;
                max-width: none;
                max-height: none;
                border-radius: 0;
                padding: 20px;
                margin: 0;
            }
            
            .faq-modal-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
                margin-bottom: 15px;
            }
            
            .faq-modal-header button {
                position: absolute !important;
                top: 15px !important;
                right: 15px !important;
            }
        }

        /* Mobile responsive map modal */
        @media (max-width: 768px) {
            .map-modal-content {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                transform: none;
                max-width: none;
                max-height: none;
                width: auto;
                height: auto;
                border-radius: 0;
                padding: 20px;
                margin: 0;
            }
            
            .map-modal-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
                margin-bottom: 15px;
            }
            
            .map-modal-header button {
                position: absolute !important;
                top: 15px !important;
                right: 15px !important;
            }
            
            #map-diagram-expanded {
                min-height: 300px;
            }
        }

        /* Historical Data Loading Styles */
        .load-earlier-container {
            text-align: center;
            margin: 15px 0;
            padding: 10px;
            border-bottom: 1px solid #333;
        }

        .load-earlier-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .load-earlier-btn:hover:not(:disabled) {
            background: #0056b3;
        }

        .load-earlier-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }

        .historical-log-entry {
            opacity: 0.8;
            border-left: 3px solid #6c757d;
        }

        .log-turn-indicator {
            font-size: 0.9em;
            color: #00bfff;
            margin-bottom: 5px;
        }

        .historical-indicator {
            color: #ffa500;
            font-size: 0.8em;
            font-style: italic;
            margin-left: 8px;
        }

        .loading-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #6c757d;
            border-radius: 50%;
            border-top-color: #007bff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .episode-selector {
            margin: 10px 0;
            padding: 10px;
            background: #2a2a2a;
            border-radius: 6px;
            border-bottom: 1px solid #333;
        }

        .episode-selector select {
            background: #1e1e1e;
            color: #00ff00;
            border: 1px solid #333;
            padding: 5px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }

        .historical-stats {
            font-size: 0.8em;
            color: #888;
            text-align: center;
            margin: 5px 0;
        }

        /* Style for the episode dropdown itself */
        #episode-dropdown {
            min-width: 200px; /* Ensure it's wide enough */
            box-shadow: 0 2px 5px rgba(0,0,0,0.15);
            border-radius: 4px;
        }

        #episode-dropdown a {
            white-space: nowrap;
        }

        #episode-dropdown span { /* For messages like 'Loading...' or 'No episodes' */
            display: block;
            padding: 5px;
            color: #777;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-info">
            <div class="header-container">
                <h1 style="margin: 0;">
                    <span class="status-indicator" id="connection-status"></span>
                    ZorkGPT Live Viewer
                </h1>
                <div class="header-links">
                    <a href="https://github.com/stickystyle/ZorkGPT" target="_blank" style="color: #007bff; text-decoration: none; font-weight: 500;">
                        📁 Project
                    </a>
                    <a href="#faq" onclick="showFAQ()" style="color: #007bff; text-decoration: none; font-weight: 500; cursor: pointer;">
                        ❓ FAQ
                    </a>
                </div>
            </div>
            <div class="info-grid">
                <div class="info-item">
                    <strong>Episode:</strong>
                    <span id="episode-id" style="cursor: pointer; text-decoration: underline; color: #007bff;">Loading...</span>
                    <div id="episode-dropdown" style="display: none; position: absolute; background-color: white; border: 1px solid #ccc; padding: 10px; z-index: 100; max-height: 200px; overflow-y: auto;">
                        <!-- Episode links will be populated here -->
                    </div>
                </div>
                <div class="info-item">
                    <strong>Turn:</strong> <span id="turn-count">-</span> / <span id="max-turns">-</span>
                </div>
                <div class="info-item">
                    <strong>Score:</strong> <span id="score">-</span>
                </div>
                <div class="info-item">
                    <strong>Location:</strong> <span id="location" class="current-room">-</span>
                </div>
                <div class="info-item">
                    <strong>Inventory:</strong> <span id="inventory">-</span>
                </div>
                <div class="info-item">
                    <strong>Deaths:</strong> <span id="death-count">0</span>
                </div>
            </div>
        </div>
        
        <div class="knowledge-section">
            <h3 id="objectives-header">Current Objectives</h3>
            <div id="objectives-content" class="loading">Loading...</div>
            
            <hr class="objectives-divider">
            
            <h3>Knowledge Base</h3>
            <div id="knowledge-content" class="loading">Loading...</div>
        </div>
        
        <div class="game-log">
            <h3 style="color: #00bfff;">Recent Game Log</h3>
            <div id="recent-log" class="loading">Loading...</div>
            <div id="new-messages-indicator" class="new-messages-indicator">
                New messages ↓
            </div>
        </div>
        
        <div class="map-container">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="margin: 0;">Game Map</h3>
                <button onclick="showExpandedMap()" style="background: #007bff; color: white; border: none; padding: 8px 12px; border-radius: 6px; cursor: pointer; font-size: 12px;">
                    🔍 Expand
                </button>
            </div>
            <div id="map-diagram" class="loading">Loading map...</div>
            <div id="map-stats" class="map-stats"></div>
        </div>
    </div>

    <!-- FAQ Modal -->
    <div id="faq-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000;">
        <div class="faq-modal-content">
            <div class="faq-modal-header">
                <h2 style="margin: 0; color: #333;">ZorkGPT Live Viewer FAQ</h2>
                <button onclick="hideFAQ()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">&times;</button>
            </div>
            <div style="line-height: 1.6; color: #444;">
                <h3>What is ZorkGPT?</h3>
                <p>ZorkGPT is an AI agent system that plays the classic interactive fiction game "Zork" using Large Language Models (LLMs). It demonstrates how AI can understand and navigate complex text-based game worlds.</p>
                
                <h3>What is Zork?</h3>
                <p><a href="https://en.wikipedia.org/wiki/Zork" target="_blank">Zork</a> is a legendary text adventure game first released in 1977, where players explore the Great Underground Empire by typing commands in natural language. Often considered the most famous piece of interactive fiction, Zork challenges players to solve puzzles, collect treasures, and navigate hundreds of locations using only text descriptions and typed commands.</p>
                
                <h3>Why Zork instead of Pokemon?</h3>
                <p>I've seen the impressive Claude and Gemini plays Pokemon projects and wanted to explore what was possible with open source models. Why didn't I try making open source models play Pokemon? Because I'm not as smart as the guys who created those projects! 😉 I originally tried to limit myself to models that could reasonably run on home systems configured for LLM inference, making this more accessible to hobbyists and researchers without massive compute budgets. However after thousands of turns, I've needed up expand to larger (still open source) models to get the best results.</p>
                
                <h3>What am I looking at?</h3>
                <p>This live viewer shows real-time data from a running ZorkGPT session, including:</p>
                <ul>
                    <li><strong>Game Info:</strong> Current episode, turn count, score, and location</li>
                    <li><strong>Knowledge Base:</strong> AI-generated strategic guides and learned patterns</li>
                    <li><strong>Game Log:</strong> Recent actions, AI reasoning, and game responses</li>
                    <li><strong>Map:</strong> Visual representation of discovered locations and connections</li>
                </ul>
                
                <h3>How does the AI work?</h3>
                <p>The system uses multiple AI components, each potentially running different open source models:</p>
                <ul>
                    <li><strong>Agent:</strong> Decides what actions to take</li>
                    <li><strong>Extractor:</strong> Parses game text into structured data</li>
                    <li><strong>Critic:</strong> Evaluates proposed actions before execution</li>
                    <li><strong>Knowledge Base:</strong> Analyzes gameplay data to generate strategic guides and learns from experience</li>
                </ul>
                <div id="current-models-info">
                    <p><strong>Current Models:</strong></p>
                    <ul>
                        <li><strong>Agent:</strong> <span id="faq-agent-model">Loading...</span></li>
                        <li><strong>Critic:</strong> <span id="faq-critic-model">Loading...</span></li>
                        <li><strong>Extractor:</strong> <span id="faq-extractor-model">Loading...</span></li>
                        <li><strong>Knowledge Base:</strong> <span id="faq-knowledge-model">Loading...</span></li>
                    </ul>
                </div>
                <p>These models may change as experiments progress to test different capabilities and performance characteristics.</p>
                
                <h3>Why isn't the data updating?</h3>
                <p>The viewer polls for updates every 3 seconds. If you see a red connection indicator, either:</p>
                <ul>
                    <li>No ZorkGPT session is currently running</li>
                    <li>The state file isn't being generated</li>
                    <li>The data is more than 10 minutes old (stale session)</li>
                    <li>There's a network connectivity issue</li>
                </ul>
                
                <h3>What do the log colors mean?</h3>
                <ul>
                    <li><span style="color: #ffeb3b;">💭 Yellow:</span> AI thinking/reasoning</li>
                    <li><span style="color: #87ceeb;">🎯 Light Blue:</span> Proposed action (final action taken)</li>
                    <li><span style="color: #ffa500;">🚫 Orange:</span> Rejected actions (if any) with critic justifications</li>
                    <li><span style="color: #ffa500;">⚖️ Orange:</span> Final critic evaluation with detailed justification</li>
                    <li><span style="color: #98fb98;">✅ Light Green:</span> Action taken</li>
                    <li><span style="color: #90ee90;">🎮 Green:</span> Game response</li>
                </ul>
                
                <h3>What does the critic evaluation show?</h3>
                <p>The critic evaluation displays:</p>
                <ul>
                    <li><strong>Status:</strong> Whether the action was approved or rejected</li>
                    <li><strong>Score:</strong> Numerical evaluation (positive = good, negative = bad)</li>
                    <li><strong>Justification:</strong> Detailed reasoning for the evaluation</li>
                    <li><strong>Override status:</strong> Whether a rejected action was overridden</li>
                </ul>
                
                <h3>Can I interact with the game?</h3>
                <p>No, this is a read-only viewer. The AI is playing autonomously. You can watch its decision-making process and see how it learns and adapts.</p>
            </div>
        </div>
    </div>

    <!-- Expanded Map Modal -->
    <div id="map-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000;">
        <div class="map-modal-content">
            <div class="map-modal-header">
                <h2 style="margin: 0; color: #333;">Game Map - Expanded View</h2>
                <button onclick="hideExpandedMap()" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">&times;</button>
            </div>
            <div class="map-modal-body">
                <div id="map-diagram-expanded" class="loading">Loading map...</div>
                <div id="map-stats-expanded" class="map-stats"></div>
            </div>
        </div>
    </div>

    <script>
        // Initialize Mermaid
        mermaid.initialize({ 
            startOnLoad: false,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true
            }
        });

        // Configuration
        const LIST_EPISODES_API_ENDPOINT = 'https://abcdef1234.execute-api.us-east-1.amazonaws.com/prod/episodes';

        // Historical Data Manager for lazy-loading turn snapshots
        // IMPORTANT: Each turn_X.json contains a complete snapshot with recent_log containing multiple turns
        // We need to be smart about which snapshots to fetch and extract only the turns we need
        class HistoricalDataManager {
            constructor(baseUrl, episodeId) {
                this.baseUrl = baseUrl;
                this.episodeId = episodeId;
                this.turnCache = new Map(); // Cache individual turn entries
                this.snapshotCache = new Map(); // Cache full snapshots
                this.maxTurnCacheSize = 200; // More turns since they're smaller
                this.maxSnapshotCacheSize = 10; // Fewer snapshots since they're larger
                this.isLoading = false;
                this.loadedTurnSet = new Set(); // Track which individual turns we have
            }

            // Smart strategy: Determine which snapshot(s) to fetch for a given turn range
            determineSnapshotsNeeded(startTurn, endTurn) {
                const snapshots = [];
                
                // Strategy: Each snapshot turn_X.json typically contains recent_log with ~10-20 turns
                // We want to minimize snapshot fetches while covering our range
                
                // For efficiency, we'll fetch snapshots at strategic intervals
                // Assume each snapshot contains ~20 turns in recent_log
                const estimatedLogSize = 20;
                
                // Find the best snapshots to fetch
                // Start from the end of our range and work backwards
                let currentTurn = endTurn;
                
                while (currentTurn >= startTurn) {
                    // Check if we already have this snapshot cached
                    const snapshotKey = `${this.episodeId}_snapshot_${currentTurn}`;
                    
                    if (!this.snapshotCache.has(snapshotKey)) {
                        snapshots.push(currentTurn);
                    }
                    
                    // Move to the next strategic snapshot
                    // Go back by estimated log size to minimize overlap
                    currentTurn -= estimatedLogSize;
                }
                
                // Also try a few key snapshots that might contain our range
                const keySnapshots = [
                    endTurn, // Latest snapshot in range
                    Math.floor((startTurn + endTurn) / 2), // Middle snapshot
                    startTurn + 10 // Snapshot likely to contain start of range
                ].filter(turn => turn >= startTurn && turn <= endTurn);
                
                // Combine and deduplicate
                const allSnapshots = [...new Set([...snapshots, ...keySnapshots])];
                
                console.log(`For range ${startTurn}-${endTurn}, will try snapshots: ${allSnapshots.join(', ')}`);
                return allSnapshots;
            }

            async fetchSnapshot(episodeId, turnNumber) {
                const cacheKey = `${episodeId}_snapshot_${turnNumber}`;
                
                if (this.snapshotCache.has(cacheKey)) {
                    // Move to end for LRU
                    const value = this.snapshotCache.get(cacheKey);
                    this.snapshotCache.delete(cacheKey);
                    this.snapshotCache.set(cacheKey, value);
                    return value;
                }

                try {
                    const url = `${this.baseUrl}/snapshots/${episodeId}/turn_${turnNumber}.json`;
                    console.log(`Fetching snapshot: ${url}`);
                    
                    const response = await fetch(url);
                    
                    if (!response.ok) {
                        if (response.status === 404) {
                            console.warn(`Snapshot turn_${turnNumber}.json not found for episode ${episodeId}`);
                            return null;
                        }
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const snapshotData = await response.json();
                    
                    // Cache management - LRU eviction for snapshots
                    if (this.snapshotCache.size >= this.maxSnapshotCacheSize) {
                        const firstKey = this.snapshotCache.keys().next().value;
                        this.snapshotCache.delete(firstKey);
                    }
                    
                    this.snapshotCache.set(cacheKey, snapshotData);
                    return snapshotData;
                    
                } catch (error) {
                    console.warn(`Failed to fetch snapshot turn_${turnNumber}.json for episode ${episodeId}:`, error);
                    return null;
                }
            }

            // Extract specific turns from a snapshot's recent_log
            extractTurnsFromSnapshot(snapshot, neededTurns) {
                if (!snapshot || !snapshot.recent_log) {
                    return [];
                }
                
                const extractedTurns = [];
                const neededSet = new Set(neededTurns);
                
                for (const logEntry of snapshot.recent_log) {
                    if (neededSet.has(logEntry.turn)) {
                        // Mark as historical and add metadata
                        const turnEntry = {
                            ...logEntry,
                            _isHistorical: true,
                            _episodeId: snapshot.metadata?.episode_id,
                            _sourceSnapshot: snapshot.metadata?.turn_count
                        };
                        
                        extractedTurns.push(turnEntry);
                        
                        // Cache this individual turn
                        const turnCacheKey = `${this.episodeId}_turn_${logEntry.turn}`;
                        this.turnCache.set(turnCacheKey, turnEntry);
                        this.loadedTurnSet.add(logEntry.turn);
                        
                        // LRU management for turn cache
                        if (this.turnCache.size > this.maxTurnCacheSize) {
                            const firstKey = this.turnCache.keys().next().value;
                            const firstTurn = this.turnCache.get(firstKey);
                            this.turnCache.delete(firstKey);
                            if (firstTurn) {
                                this.loadedTurnSet.delete(firstTurn.turn);
                            }
                        }
                    }
                }
                
                console.log(`Extracted ${extractedTurns.length} turns from snapshot (turn ${snapshot.metadata?.turn_count})`);
                return extractedTurns;
            }

            async loadTurnRange(episodeId, startTurn, endTurn) {
                console.log(`Loading turn range: ${startTurn}-${endTurn} for episode ${episodeId}`);
                
                // First, check what turns we already have cached
                const neededTurns = [];
                for (let turn = startTurn; turn <= endTurn; turn++) {
                    if (!this.loadedTurnSet.has(turn)) {
                        neededTurns.push(turn);
                    }
                }
                
                if (neededTurns.length === 0) {
                    console.log(`All turns ${startTurn}-${endTurn} already cached`);
                    return this.getCachedTurnsInRange(startTurn, endTurn);
                }
                
                console.log(`Need to fetch turns: ${neededTurns.join(', ')}`);
                
                // Determine which snapshots to fetch
                const snapshotsToFetch = this.determineSnapshotsNeeded(Math.min(...neededTurns), Math.max(...neededTurns));
                
                // Fetch snapshots in parallel
                const snapshotPromises = snapshotsToFetch.map(turnNum =>
                    this.fetchSnapshot(episodeId, turnNum)
                );
                
                const snapshots = await Promise.allSettled(snapshotPromises);
                const successfulSnapshots = snapshots
                    .filter(result => result.status === 'fulfilled' && result.value !== null)
                    .map(result => result.value);
                
                console.log(`Fetched ${successfulSnapshots.length}/${snapshotsToFetch.length} snapshots`);
                
                // Extract needed turns from all snapshots
                const allExtractedTurns = [];
                for (const snapshot of successfulSnapshots) {
                    const extractedTurns = this.extractTurnsFromSnapshot(snapshot, neededTurns);
                    allExtractedTurns.push(...extractedTurns);
                }
                
                // Remove duplicates (same turn from multiple snapshots)
                const uniqueTurns = allExtractedTurns.filter((turn, index, arr) =>
                    arr.findIndex(t => t.turn === turn.turn) === index
                );
                
                console.log(`Successfully loaded ${uniqueTurns.length} unique turns from range ${startTurn}-${endTurn}`);
                
                // Return all turns in the requested range (cached + newly loaded)
                return this.getCachedTurnsInRange(startTurn, endTurn);
            }

            getCachedTurnsInRange(startTurn, endTurn) {
                const turns = [];
                for (let turn = startTurn; turn <= endTurn; turn++) {
                    const turnCacheKey = `${this.episodeId}_turn_${turn}`;
                    const cachedTurn = this.turnCache.get(turnCacheKey);
                    if (cachedTurn) {
                        turns.push(cachedTurn);
                    }
                }
                return turns.sort((a, b) => a.turn - b.turn);
            }

            getCachedTurn(episodeId, turnNumber) {
                const turnCacheKey = `${episodeId}_turn_${turnNumber}`;
                return this.turnCache.get(turnCacheKey) || null;
            }

            invalidateCache() {
                this.turnCache.clear();
                this.snapshotCache.clear();
                this.loadedTurnSet.clear();
            }

            getLoadedStats() {
                return {
                    cachedTurns: this.turnCache.size,
                    cachedSnapshots: this.snapshotCache.size,
                    loadedTurnCount: this.loadedTurnSet.size,
                    loadedTurns: Array.from(this.loadedTurnSet).sort((a, b) => a - b)
                };
            }
        }

        class ZorkGameViewer {
            constructor(stateUrl) {
                this.stateUrl = stateUrl;
                this.currentState = null;
                this.pollInterval = 3000; // 3 seconds
                this.mapCounter = 0; // For unique mermaid IDs
                this.isConnected = false;
                this.hasScrolled = false; // Track if user has manually scrolled
                this.userScrolledUp = false; // Track if user scrolled up from bottom
                this.lastLogCount = 0; // Track log count for new message detection
                this.scrollAnimation = null; // Track current scroll animation
                
                // Historical data management
                this.historicalDataManager = null;
                this.allLogEntries = []; // Combined current + historical
                this.displayedLogCount = 20; // Initially show 20 entries
                this.isLoadingHistorical = false;
                this.earliestLoadedTurn = null;

                // S3 and API endpoint configurations
                this.s3BaseUrl = 'https://my-zorkgpt-data-bucket.s3.us-east-1.amazonaws.com';
                this.s3KeyPrefix = 'zorkgpt_data/'; // Should match orchestrator and lambda

                // New properties for episode selection
                this.listEpisodesApiEndpoint = LIST_EPISODES_API_ENDPOINT; // Use the constant
                this.allEpisodeIds = [];
                this.currentSelectedEpisodeId = null; // To track which episode's data is loaded
                this.liveEpisodeId = null; // To store the ID of the initially loaded live episode

                this.startPolling(); // Existing call
                this.silentlyFetchInitialEpisodeList(); // New call
                this.setupEpisodeSelection(); // New call
            }

            async silentlyFetchInitialEpisodeList() {
                try {
                    const response = await fetch(this.listEpisodesApiEndpoint);
                    if (!response.ok) {
                        console.warn('Silently failed to fetch initial episode list:', response.status);
                        // Optionally update a status somewhere or just fail silently
                        const dropdown = document.getElementById('episode-dropdown');
                        if(dropdown) dropdown.innerHTML = '<span>Failed to load episode list. Click Episode ID to retry.</span>';
                        return;
                    }
                    const data = await response.json();
                    this.allEpisodeIds = data.episodes || [];
                    this.allEpisodeIds.sort().reverse(); // Sort, newest first
                    console.log('Initial episode list fetched:', this.allEpisodeIds);
                } catch (error) {
                    console.warn('Error silently fetching initial episode list:', error);
                    const dropdown = document.getElementById('episode-dropdown');
                    if(dropdown) dropdown.innerHTML = '<span>Error fetching episodes. Click Episode ID to retry.</span>';
                }
            }

            async fetchEpisodeListAndDisplayDropdown() {
                const dropdown = document.getElementById('episode-dropdown');
                if (!dropdown) return;
                dropdown.innerHTML = '<span>Loading episodes...</span>'; // Loading indicator

                try {
                    const response = await fetch(this.listEpisodesApiEndpoint);
                    if (!response.ok) {
                        console.error('Failed to fetch episode list:', response.status);
                        if(dropdown) dropdown.innerHTML = '<span>Error loading episodes.</span>';
                        return;
                    }
                    const data = await response.json();
                    this.allEpisodeIds = data.episodes || [];
                    this.allEpisodeIds.sort().reverse(); // Sort, newest first
                    this.populateEpisodeDropdown(this.allEpisodeIds);
                } catch (error) {
                    console.error('Error fetching episode list:', error);
                    if(dropdown) dropdown.innerHTML = '<span>Error loading episodes.</span>';
                }
            }

            populateEpisodeDropdown(episodeIds) {
                const dropdown = document.getElementById('episode-dropdown');
                if (!dropdown) return;
                dropdown.innerHTML = ''; // Clear existing items

                if (episodeIds.length === 0) {
                    dropdown.innerHTML = '<span>No other episodes found.</span>';
                    return;
                }

                // Ensure liveEpisodeId is set if not already
                if (!this.liveEpisodeId && this.currentState && this.currentState.metadata) {
                   this.liveEpisodeId = this.currentState.metadata.episode_id;
                }


                episodeIds.forEach(id => {
                    const link = document.createElement('a');
                    link.href = '#';
                    let label = id;
                    if (id === this.liveEpisodeId) {
                        label += ' (Live)';
                    } else if (id === this.currentSelectedEpisodeId) {
                        label += ' (Current)';
                    }

                    link.textContent = label;
                    link.style.display = 'block';
                    link.style.padding = '5px';
                    link.style.textDecoration = 'none';
                    link.style.color = '#333';
                    link.onmouseover = () => link.style.backgroundColor = '#f0f0f0';
                    link.onmouseout = () => link.style.backgroundColor = 'white';
                    link.onclick = (e) => {
                        e.preventDefault();
                        // Only load if different from the currently displayed episode data source
                        if (id !== this.currentSelectedEpisodeId) {
                            this.loadEpisode(id);
                        }
                        dropdown.style.display = 'none';
                    };
                    dropdown.appendChild(link);
                });
            }

            setupEpisodeSelection() {
                const episodeIdElement = document.getElementById('episode-id');
                const episodeDropdownElement = document.getElementById('episode-dropdown');

                if (episodeIdElement && episodeDropdownElement) {
                    episodeIdElement.addEventListener('click', () => {
                        if (episodeDropdownElement.style.display === 'none') {
                            this.fetchEpisodeListAndDisplayDropdown();
                            episodeDropdownElement.style.display = 'block';
                        } else {
                            episodeDropdownElement.style.display = 'none';
                        }
                    });

                    document.addEventListener('click', (event) => {
                        if (!episodeIdElement.contains(event.target) && !episodeDropdownElement.contains(event.target)) {
                            episodeDropdownElement.style.display = 'none';
                        }
                    });
                }
            }

            async loadEpisode(episodeId) {
                console.log(`Attempting to load episode: ${episodeId}`);
                document.getElementById('episode-id').textContent = episodeId + " (Loading...)";

                // 1. Clear Current State & UI
                this.currentState = null;
                this.allLogEntries = []; // Will be repopulated by historical data manager
                this.displayedLogCount = 20;
                this.earliestLoadedTurn = null; // Reset for historical manager
                this.lastLogCount = 0;
                // Any other specific state tied to a single episode view
                
                const logContainer = document.getElementById('recent-log');
                if (logContainer) logContainer.innerHTML = '<div class="loading">Loading episode log...</div>';
                const mapContainer = document.getElementById('map-diagram');
                if (mapContainer) mapContainer.innerHTML = '<div class="loading">Loading map...</div>';
                const objectivesContainer = document.getElementById('objectives-content');
                if (objectivesContainer) objectivesContainer.innerHTML = '<div class="loading">Loading objectives...</div>';
                const knowledgeContainer = document.getElementById('knowledge-content');
                if (knowledgeContainer) knowledgeContainer.innerHTML = '<div class="loading">Loading knowledge base...</div>';
                // Reset info fields that are not episode ID
                document.getElementById('turn-count').textContent = "-";
                document.getElementById('max-turns').textContent = "-";
                document.getElementById('score').textContent = "-";
                document.getElementById('location').textContent = "-";
                document.getElementById('inventory').textContent = "-";
                document.getElementById('death-count').textContent = "0";


                // 2. Update Episode ID Tracking
                this.currentSelectedEpisodeId = episodeId;

                // 3. Initialize HistoricalDataManager for the new episode
                const s3FullPath = this.s3BaseUrl.endsWith('/') ? this.s3BaseUrl + this.s3KeyPrefix : this.s3BaseUrl + '/' + this.s3KeyPrefix;
                this.historicalDataManager = new HistoricalDataManager(s3FullPath, episodeId);
                this.historicalDataManager.invalidateCache(); // Clear any cache from previous episode

                // 4. Fetch Initial State for Selected Episode (e.g., a very early turn snapshot)
                try {
                    // Attempt to load turn 1 (or a known early turn) to get initial metadata and state
                    let initialSnapshot = await this.historicalDataManager.fetchSnapshot(episodeId, 1);

                    if (!initialSnapshot) {
                        console.warn(`Snapshot turn_1 not found for ${episodeId}.`);
                         throw new Error("Could not load initial snapshot for episode (turn_1 missing).");
                    }

                    this.currentState = initialSnapshot;

                    if (this.currentState.recent_log) {
                         this.historicalDataManager.extractTurnsFromSnapshot(this.currentState, this.currentState.recent_log.map(entry => entry.turn));
                    }

                    this.updateUI();
                    this.updateGameInfo();
                    this.updateRecentLog();

                } catch (error) {
                    console.error(`Failed to load episode ${episodeId}:`, error);
                    document.getElementById('episode-id').textContent = episodeId + " (Error)";
                    if (logContainer) logContainer.innerHTML = `<div class="error-message">Error loading episode ${episodeId}: ${error.message}</div>`;
                }
            }
            
            async fetchCurrentState() {
                try {
                    // If a historical episode is selected, don't poll for live state.
                    // The only exception is if the user selects the "live" episode again.
                    if (this.currentSelectedEpisodeId && this.currentSelectedEpisodeId !== this.liveEpisodeId) {
                        // console.log(`Polling skipped for historical episode: ${this.currentSelectedEpisodeId}`);
                        return;
                    }

                    const response = await fetch(this.stateUrl);
                    if (response.ok) {
                        const newState = await response.json();
                        
                        // Check if the timestamp is fresh (within last 10 minutes)
                        const isFresh = this.isTimestampFresh(newState.metadata.timestamp);
                        
                        // Only update if state actually changed
                        if (!this.currentState || 
                            this.currentState.metadata.turn_count !== newState.metadata.turn_count ||
                            this.currentState.metadata.timestamp !== newState.metadata.timestamp) {

                            this.currentState = newState;

                            // Store the live episode ID when it's first loaded
                            if (!this.liveEpisodeId) {
                                this.liveEpisodeId = newState.metadata.episode_id;
                                // If currentSelectedEpisodeId hasn't been set by user action, it's the live one
                                if (!this.currentSelectedEpisodeId) {
                                    this.currentSelectedEpisodeId = this.liveEpisodeId;
                                }
                            }
                            this.updateUI();
                        }
                        
                        // Set connection status based on data freshness
                        this.setConnectionStatus(isFresh);
                        
                        if (!isFresh) {
                            console.warn('Game state is stale (more than 10 minutes old)');
                        }
                    } else {
                        this.setConnectionStatus(false);
                        console.error('Failed to fetch game state:', response.status);
                    }
                } catch (error) {
                    this.setConnectionStatus(false);
                    console.error('Failed to fetch game state:', error);
                }
            }
            
            isTimestampFresh(timestamp) {
                if (!timestamp) {
                    console.warn('No timestamp found in state data');
                    return false;
                }
                
                try {
                    // Parse the timestamp (assuming ISO format)
                    const stateTime = new Date(timestamp);
                    const currentTime = new Date();
                    const diffMinutes = (currentTime - stateTime) / (1000 * 60); // Convert to minutes
                    
                    console.log(`State timestamp: ${timestamp}, Age: ${diffMinutes.toFixed(1)} minutes`);
                    
                    // Consider fresh if less than 10 minutes old
                    return diffMinutes < 10;
                } catch (error) {
                    console.error('Failed to parse timestamp:', error);
                    return false;
                }
            }
            
            setConnectionStatus(connected) {
                this.isConnected = connected;
                const indicator = document.getElementById('connection-status');
                indicator.className = `status-indicator ${connected ? 'status-connected' : 'status-disconnected'}`;
                
                if (!connected && !this.currentState) {
                    document.getElementById('episode-id').textContent = 'Connection Error';
                } else if (!connected && this.currentState) {
                    // We have data but it's stale
                    const episodeElement = document.getElementById('episode-id');
                    if (!episodeElement.textContent.includes('(Stale)')) {
                        episodeElement.textContent = this.currentState.metadata.episode_id + ' (Stale)';
                    }
                }
            }
            
            startPolling() {
                this.fetchCurrentState();
                setInterval(() => this.fetchCurrentState(), this.pollInterval);
                
                // Add scroll event listener to detect manual scrolling
                const logContainer = document.getElementById('recent-log');
                const gameLogContainer = logContainer ? logContainer.parentElement : null;
                const newMessagesIndicator = document.getElementById('new-messages-indicator');
                
                console.log('Log container:', logContainer);
                console.log('Game log container:', gameLogContainer);
                
                // Use the parent container that has overflow-y: auto
                const scrollableContainer = gameLogContainer || logContainer;
                
                if (scrollableContainer) {
                    scrollableContainer.addEventListener('scroll', () => {
                        // Check if user scrolled away from bottom (with a small tolerance)
                        const isAtBottom = scrollableContainer.scrollHeight - scrollableContainer.clientHeight <= scrollableContainer.scrollTop + 5;
                        if (!isAtBottom) {
                            this.userScrolledUp = true;
                            console.log('User scrolled up from bottom');
                        } else {
                            this.userScrolledUp = false;
                            console.log('User is at bottom');
                            // Hide indicator when user scrolls back to bottom
                            if (newMessagesIndicator) {
                                newMessagesIndicator.style.display = 'none';
                            }
                        }
                    });
                }
                
                // Add click handler for new messages indicator
                if (newMessagesIndicator) {
                    newMessagesIndicator.addEventListener('click', () => {
                        this.smoothScrollToBottom(scrollableContainer);
                        this.userScrolledUp = false;
                        newMessagesIndicator.style.display = 'none';
                    });
                }
            }
            
            updateUI() {
                if (!this.currentState) return;
                
                this.updateGameInfo();
                this.updateMap();
                this.updateRecentLog();
                this.updateObjectives();
                this.updateKnowledgeBase();
            }
            
            updateGameInfo() {
                const meta = this.currentState.metadata;
                const current = this.currentState.current_state;
                
                // Update episode ID display, potentially indicating if it's live or selected historical
                let episodeDisplayText = meta.episode_id || 'N/A';
                if (this.currentSelectedEpisodeId) {
                    episodeDisplayText = this.currentSelectedEpisodeId;
                    if (this.liveEpisodeId && this.currentSelectedEpisodeId === this.liveEpisodeId) {
                        episodeDisplayText += " (Live)";
                    } else if (this.liveEpisodeId && this.currentSelectedEpisodeId !== this.liveEpisodeId) {
                         episodeDisplayText += " (Historical)";
                    }
                }
                document.getElementById('episode-id').style.color = '#007bff'; // Ensure clickable style if not already set
                document.getElementById('episode-id').style.textDecoration = 'underline';
                document.getElementById('episode-id').style.cursor = 'pointer';
                document.getElementById('episode-id').textContent = episodeDisplayText;

                document.getElementById('turn-count').textContent = meta.turn_count;
                document.getElementById('max-turns').textContent = meta.max_turns;
                document.getElementById('score').textContent = meta.score;
                document.getElementById('location').textContent = current.location;
                document.getElementById('inventory').textContent = 
                    current.inventory.length > 0 ? current.inventory.join(', ') : 'Empty';
                document.getElementById('death-count').textContent = 
                    current.death_count || 0;
                
                // Update FAQ model information
                if (meta.models) {
                    document.getElementById('faq-agent-model').textContent = meta.models.agent || 'Unknown';
                    document.getElementById('faq-critic-model').textContent = meta.models.critic || 'Unknown';
                    document.getElementById('faq-extractor-model').textContent = meta.models.extractor || 'Unknown';
                    document.getElementById('faq-knowledge-model').textContent = meta.models.knowledge_base || 'Unknown';
                } else {
                    document.getElementById('faq-agent-model').textContent = 'Not available';
                    document.getElementById('faq-critic-model').textContent = 'Not available';
                    document.getElementById('faq-extractor-model').textContent = 'Not available';
                    document.getElementById('faq-knowledge-model').textContent = 'Not available';
                }
            }
            
            async updateMap() {
                const mapData = this.currentState.map;
                const mapContainer = document.getElementById('map-diagram');
                const mapStats = document.getElementById('map-stats');
                
                if (!mapContainer) {
                    console.error('Map container not found');
                    return;
                }
                
                if (!mapData || !mapData.mermaid_diagram) {
                    mapContainer.innerHTML = '<p class="error-message">No map data available</p>';
                    return;
                }

                await this.renderMapToContainer('map-diagram', 'map-stats');
            }
            
            async renderMapToContainer(diagramElementId, statsElementId) {
                const mapData = this.currentState.map;
                const mapContainer = document.getElementById(diagramElementId);
                const mapStats = document.getElementById(statsElementId);
                
                if (!mapContainer) {
                    console.error('Map container not found:', diagramElementId);
                    return;
                }
                
                if (!mapData || !mapData.mermaid_diagram) {
                    mapContainer.innerHTML = '<p class="error-message">No map data available</p>';
                    return;
                }

                try {
                    // Create unique ID for this map render
                    this.mapCounter++;
                    const mapId = `mermaid-map-${this.mapCounter}`;
                    
                    console.log('Rendering map with ID:', mapId);
                    console.log('Mermaid code:', mapData.mermaid_diagram);
                    
                    // Highlight current room in the diagram
                    let mermaidCode = mapData.mermaid_diagram;
                    
                    // Add styling to highlight current room
                    if (mapData.current_room) {
                        console.log('Current room to highlight:', mapData.current_room);
                        mermaidCode += `\n    classDef currentRoom fill:#ffeb3b,stroke:#f57f17,stroke-width:3px`;
                        
                        // Find the node ID for current room and apply class
                        const lines = mermaidCode.split('\n');
                        let foundMatch = false;
                        for (let i = 0; i < lines.length; i++) {
                            console.log('Checking line:', lines[i]);
                            if (lines[i].includes(`"${mapData.current_room}"`)) {
                                console.log('Found matching line:', lines[i]);
                                const nodeMatch = lines[i].match(/^\s*(\w+)\[/);
                                if (nodeMatch) {
                                    console.log('Applying class to node:', nodeMatch[1]);
                                    mermaidCode += `\n    class ${nodeMatch[1]} currentRoom`;
                                    foundMatch = true;
                                    break;
                                }
                            }
                        }
                        if (!foundMatch) {
                            console.warn('Could not find current room in mermaid diagram:', mapData.current_room);
                        }
                    }
                    
                    // Render the mermaid diagram directly to the container
                    const { svg } = await mermaid.render(mapId, mermaidCode);
                    
                    // Set the SVG directly to the container
                    mapContainer.innerHTML = svg;
                    
                    // Update map stats
                    if (mapStats) {
                        mapStats.innerHTML = `
                            <strong>Map Stats:</strong> 
                            ${mapData.total_rooms} rooms, 
                            ${mapData.total_connections} connections
                        `;
                    }
                    
                } catch (error) {
                    console.error('Failed to render map:', error);
                    mapContainer.innerHTML = `<p class="error-message">Error rendering map: ${error.message}</p>`;
                }
            }
            
            updateRecentLog() {
                const logContainer = document.getElementById('recent-log');
                const newMessagesIndicator = document.getElementById('new-messages-indicator');
                
                // Get current logs from state
                const currentLogs = this.currentState.recent_log || [];
                
                if (currentLogs.length === 0) {
                    logContainer.innerHTML = '<div class="log-entry">No recent actions</div>';
                    return;
                }
                
                // Merge with any loaded historical data
                this.mergeLogEntries(currentLogs);
                
                // Display the requested number of entries
                const logsToDisplay = this.allLogEntries.slice(-this.displayedLogCount);
                
                // Check if there are new messages
                const currentLogCount = currentLogs.length;
                const hasNewMessages = this.lastLogCount && currentLogCount > this.lastLogCount;
                this.lastLogCount = currentLogCount;
                
                // Add "Load Earlier Turns" button if there might be more data
                let loadEarlierButton = '';
                if (this.canLoadEarlierTurns()) {
                    const stats = this.historicalDataManager ? this.historicalDataManager.getLoadedStats() : null;
                    const statsText = stats ? ` (${stats.loadedTurnCount} cached)` : '';
                    
                    loadEarlierButton = `
                        <div class="load-earlier-container">
                            <button id="load-earlier-btn" class="load-earlier-btn" ${this.isLoadingHistorical ? 'disabled' : ''}>
                                ${this.isLoadingHistorical ? '<span class="loading-spinner"></span>Loading...' : 'Load Earlier Turns'}
                            </button>
                            ${stats ? `<div class="historical-stats">Cache: ${stats.cachedTurns}/${stats.loadedTurnCount} turns${statsText}</div>` : ''}
                        </div>
                    `;
                }

                // Render log entries
                const logHtml = loadEarlierButton + logsToDisplay.map(entry => {
                    return this.renderLogEntry(entry);
                }).join('');

                logContainer.innerHTML = logHtml;

                // Add event listener for load earlier button
                const loadEarlierBtn = document.getElementById('load-earlier-btn');
                if (loadEarlierBtn) {
                    loadEarlierBtn.addEventListener('click', () => this.loadEarlierTurns());
                }

                // Auto-scroll logic (same as before)
                if (!this.userScrolledUp) {
                    console.log('Auto-scrolling to bottom smoothly');
                    setTimeout(() => {
                        const gameLogContainer = logContainer ? logContainer.parentElement : null;
                        const scrollableContainer = gameLogContainer || logContainer;
                        
                        if (this.scrollAnimation) {
                            console.log('Animation already running, will restart after completion');
                            cancelAnimationFrame(this.scrollAnimation);
                            this.scrollAnimation = null;
                            setTimeout(() => {
                                this.smoothScrollToBottom(scrollableContainer);
                            }, 100);
                        } else {
                            this.smoothScrollToBottom(scrollableContainer);
                        }
                        
                        if (newMessagesIndicator) {
                            newMessagesIndicator.style.display = 'none';
                        }
                    }, 50);
                } else if (hasNewMessages && this.userScrolledUp) {
                    console.log('User scrolled up, showing new messages indicator');
                    if (newMessagesIndicator) {
                        newMessagesIndicator.style.display = 'block';
                    }
                }
                
                this.hasScrolled = true;
            }
            
            updateObjectives() {
                const objectivesContainer = document.getElementById('objectives-content');
                const objectivesHeader = document.getElementById('objectives-header');
                const currentState = this.currentState.current_state;
                const objectives = currentState ? currentState.discovered_objectives : null;
                
                if (!objectives || objectives.length === 0) {
                    objectivesContainer.innerHTML = '<p style="color: #666; font-style: italic;">No current objectives</p>';
                    objectivesHeader.textContent = 'Current Objectives';
                    return;
                }
                
                // Update header with count
                objectivesHeader.textContent = `Current Objectives (${objectives.length})`;
                
                try {
                    // Create a nicely formatted list of objectives
                    let objectivesHtml = '<ul class="objectives-list">';
                    
                    objectives.forEach((objective, index) => {
                        // Clean up the objective text by removing brackets if present
                        let cleanObjective = objective.trim();
                        if (cleanObjective.startsWith('[') && cleanObjective.includes(']')) {
                            cleanObjective = cleanObjective.substring(1);
                            const endBracket = cleanObjective.indexOf(']');
                            if (endBracket !== -1) {
                                const title = cleanObjective.substring(0, endBracket);
                                let description = cleanObjective.substring(endBracket + 1).trim();
                                
                                // Remove leading parenthesis and trailing parenthesis if present
                                if (description.startsWith('(') && description.endsWith(')')) {
                                    description = description.substring(1, description.length - 1);
                                }
                                
                                cleanObjective = `<strong>${this.escapeHtml(title)}</strong>`;
                                if (description) {
                                    cleanObjective += `<br><small style="color: #666; line-height: 1.3;">${this.escapeHtml(description)}</small>`;
                                }
                            }
                        } else {
                            cleanObjective = this.escapeHtml(cleanObjective);
                        }
                        
                        objectivesHtml += `<li class="objective-item">${cleanObjective}</li>`;
                    });
                    
                    objectivesHtml += '</ul>';
                    objectivesContainer.innerHTML = objectivesHtml;
                    
                } catch (error) {
                    console.error('Failed to render objectives:', error);
                    objectivesContainer.innerHTML = `<p class="error-message">Error rendering objectives: ${error.message}</p>`;
                }
            }
            
            updateKnowledgeBase() {
                const knowledgeContainer = document.getElementById('knowledge-content');
                const knowledge = this.currentState.knowledge_base;
                
                if (!knowledge || !knowledge.content) {
                    knowledgeContainer.innerHTML = '<p class="error-message">No knowledge base available</p>';
                    return;
                }
                
                try {
                    // Configure marked.js for better rendering
                    marked.setOptions({
                        breaks: true,        // Convert line breaks to <br>
                        gfm: true,          // GitHub Flavored Markdown
                        headerIds: false,   // Don't add IDs to headers
                        mangle: false       // Don't mangle email addresses
                    });
                    
                    // Convert markdown to HTML using marked.js
                    const htmlContent = marked.parse(knowledge.content);
                    
                    knowledgeContainer.innerHTML = htmlContent;
                    
                } catch (error) {
                    console.error('Failed to render knowledge base markdown:', error);
                    knowledgeContainer.innerHTML = `<p class="error-message">Error rendering knowledge base: ${error.message}</p>`;
                }
            }
            
            smoothScrollToBottom(container) {
                console.log('smoothScrollToBottom called');
                console.log('Container:', container);
                console.log('Container scrollTop:', container.scrollTop);
                console.log('Container scrollHeight:', container.scrollHeight);
                console.log('Container clientHeight:', container.clientHeight);
                
                // Cancel any existing animation
                if (this.scrollAnimation) {
                    cancelAnimationFrame(this.scrollAnimation);
                }
                
                const startPosition = container.scrollTop;
                const targetPosition = container.scrollHeight - container.clientHeight;
                const distance = targetPosition - startPosition;
                const duration = 800; // 800ms animation
                
                console.log('Start position:', startPosition);
                console.log('Target position:', targetPosition);
                console.log('Distance to scroll:', distance);
                
                // If already at bottom or no distance to scroll, return early
                if (distance <= 5) { // Small tolerance for "close enough"
                    console.log('Already at bottom or no distance to scroll');
                    return;
                }
                
                const startTime = performance.now();
                
                // Easing function for smooth animation (ease-out)
                const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);
                
                const animateScroll = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Apply easing function
                    const easedProgress = easeOutCubic(progress);
                    
                    // Recalculate target in case content changed during animation
                    const currentTarget = container.scrollHeight - container.clientHeight;
                    
                    // If content has grown significantly, adjust our animation
                    if (currentTarget > targetPosition + 50) {
                        console.log('Content grew during animation, adjusting target');
                        // Smoothly transition to the new target
                        const adjustedTarget = currentTarget;
                        const currentPos = container.scrollTop;
                        const remainingDistance = adjustedTarget - currentPos;
                        const adjustedPosition = currentPos + (remainingDistance * easedProgress);
                        container.scrollTop = Math.min(adjustedPosition, adjustedTarget);
                    } else {
                        // Normal animation
                        const currentPosition = startPosition + (distance * easedProgress);
                        container.scrollTop = Math.min(currentPosition, currentTarget);
                    }
                    
                    if (progress === 0 || progress === 1 || elapsed % 200 < 16) {
                        console.log(`Animation progress: ${(progress * 100).toFixed(1)}%, scrollTop: ${container.scrollTop}, target: ${currentTarget}`);
                    }
                    
                    // Continue animation if not complete
                    if (progress < 1) {
                        this.scrollAnimation = requestAnimationFrame(animateScroll);
                    } else {
                        console.log('Animation complete');
                        this.scrollAnimation = null;
                        
                        // Final check - make sure we're actually at the bottom
                        const finalTarget = container.scrollHeight - container.clientHeight;
                        if (Math.abs(container.scrollTop - finalTarget) > 5) {
                            console.log('Final position adjustment needed');
                            container.scrollTop = finalTarget;
                        }
                    }
                };
                
                // Start the animation
                this.scrollAnimation = requestAnimationFrame(animateScroll);
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            // Historical data management methods
            mergeLogEntries(currentLogs) {
                // Get any cached historical turns
                const historicalTurns = [];
                if (this.historicalDataManager) {
                    const stats = this.historicalDataManager.getLoadedStats();
                    for (const turn of stats.loadedTurns) {
                        const cachedTurn = this.historicalDataManager.getCachedTurn(this.currentState.metadata.episode_id, turn);
                        if (cachedTurn) {
                            historicalTurns.push(cachedTurn);
                        }
                    }
                }
                
                // Combine historical and current logs, removing duplicates
                const allLogs = [...historicalTurns, ...currentLogs];
                
                // Remove duplicates by turn number (keep the most recent version)
                const uniqueLogs = allLogs.filter((log, index, arr) =>
                    arr.findIndex(l => l.turn === log.turn) === index
                );
                
                // Sort by turn number
                this.allLogEntries = uniqueLogs.sort((a, b) => a.turn - b.turn);
                
                console.log(`Merged logs: ${historicalTurns.length} historical + ${currentLogs.length} current = ${this.allLogEntries.length} total`);
            }

            canLoadEarlierTurns() {
                // Check if we have an episode ID and turn count to potentially load earlier data
                if (!this.currentState || !this.currentState.metadata) {
                    return false;
                }
                
                const currentTurn = this.currentState.metadata.turn_count;
                const episodeId = this.currentState.metadata.episode_id;
                
                // Only show load button if we're past turn 20 and have episode info
                return currentTurn > 20 && episodeId;
            }

            async loadEarlierTurns() {
                if (this.isLoadingHistorical) {
                    return;
                }

                this.isLoadingHistorical = true;
                
                // Update button state immediately
                this.updateLoadEarlierButton();
                
                try {
                    // Initialize historical data manager if needed
                    if (!this.historicalDataManager) {
                        const episodeId = this.currentState.metadata.episode_id;
                        this.historicalDataManager = new HistoricalDataManager('./zorkgpt', episodeId);
                    }

                    // Determine range to load (20 turns before earliest loaded)
                    const currentTurn = this.currentState.metadata.turn_count;
                    let startTurn = Math.max(1, currentTurn - this.displayedLogCount - 20);
                    let endTurn = Math.max(1, currentTurn - this.displayedLogCount);

                    if (this.earliestLoadedTurn !== null) {
                        endTurn = this.earliestLoadedTurn - 1;
                        startTurn = Math.max(1, endTurn - 19);
                    }

                    console.log(`Loading historical turns ${startTurn}-${endTurn}`);

                    // Load the historical data
                    const historicalTurns = await this.historicalDataManager.loadTurnRange(
                        this.currentState.metadata.episode_id,
                        startTurn,
                        endTurn
                    );

                    if (historicalTurns.length > 0) {
                        // Update earliest loaded turn
                        this.earliestLoadedTurn = Math.min(...historicalTurns.map(t => t.turn));
                        
                        // Increase displayed count
                        this.displayedLogCount += 20;
                        
                        console.log(`Loaded ${historicalTurns.length} historical turns`);
                    } else {
                        console.log('No historical turns found in range');
                    }

                } catch (error) {
                    console.error('Failed to load historical turns:', error);
                } finally {
                    this.isLoadingHistorical = false;
                    
                    // Always refresh the log display to update button state
                    this.updateRecentLog();
                }
            }

            updateLoadEarlierButton() {
                const loadEarlierBtn = document.getElementById('load-earlier-btn');
                if (!loadEarlierBtn) return;

                const stats = this.historicalDataManager ? this.historicalDataManager.getLoadedStats() : null;
                
                if (this.isLoadingHistorical) {
                    loadEarlierBtn.disabled = true;
                    loadEarlierBtn.innerHTML = '<span class="loading-spinner"></span>Loading...';
                } else {
                    loadEarlierBtn.disabled = false;
                    loadEarlierBtn.innerHTML = 'Load Earlier Turns';
                }

                // Update stats display
                const statsElement = loadEarlierBtn.parentElement.querySelector('.historical-stats');
                if (statsElement && stats) {
                    const statsText = ` (${stats.loadedTurnCount} cached)`;
                    statsElement.textContent = `Cache: ${stats.cachedTurns}/${stats.loadedTurnCount} turns${statsText}`;
                }
            }

            renderLogEntry(entry) {
                const isHistorical = entry._isHistorical || false;
                const historicalClass = isHistorical ? ' historical-log-entry' : '';
                const historicalIndicator = isHistorical ? '<span class="historical-indicator">(Historical)</span>' : '';

                let html = `<div class="log-entry${historicalClass}">`;
                
                // Turn header
                html += `<div class="log-turn-header">Turn ${entry.turn}${historicalIndicator}</div>`;
                
                // Thinking section
                if (entry.reasoning) {
                    html += `<div class="log-thinking">💭 Thinking: ${this.escapeHtml(entry.reasoning)}</div>`;
                }
                
                // Proposed action
                if (entry.action) {
                    html += `<div class="log-proposed-action">🎯 Proposed Action: ${this.escapeHtml(entry.action)}</div>`;
                }
                
                // Rejected actions section (if any)
                if (entry.rejected_actions && entry.rejected_actions.length > 0) {
                    html += `<div class="log-critic">🚫 Rejected Actions:</div>`;
                    entry.rejected_actions.forEach((rejected, index) => {
                        html += `<div class="log-critic" style="margin-left: 20px;">${index + 1}. "${this.escapeHtml(rejected.action)}" (Score: ${rejected.score.toFixed(2)})<br>"${this.escapeHtml(rejected.justification)}"</div>`;
                    });
                }
                
                // Final critic evaluation
                if (entry.critic_justification) {
                    const status = entry.was_overridden ? 'Action rejected' : 'Action approved';
                    const score = entry.critic_score !== undefined ? entry.critic_score.toFixed(2) : 'N/A';
                    html += `<div class="log-critic">⚖️ Final Critic Evaluation: ${status} (Score: ${score})<br>"${this.escapeHtml(entry.critic_justification)}"</div>`;
                }
                
                // Action taken
                if (entry.action) {
                    html += `<div class="log-action-taken">✅ Action Taken: ${this.escapeHtml(entry.action)}</div>`;
                }
                
                // Game response
                if (entry.zork_response) {
                    html += `<div class="log-response">🎮 Game Response:<br>${this.escapeHtml(entry.zork_response).replace(/\n/g, '<br>')}</div>`;
                }
                
                html += '</div>';
                return html;
            }
        }

        // FAQ Modal Functions
        function showFAQ() {
            document.getElementById('faq-modal').style.display = 'block';
        }
        
        function hideFAQ() {
            document.getElementById('faq-modal').style.display = 'none';
        }

        // Map Modal Functions
        function showExpandedMap() {
            document.getElementById('map-modal').style.display = 'block';
            // Re-render the map in the expanded view
            if (window.zorkViewer && window.zorkViewer.currentState) {
                window.zorkViewer.renderMapToContainer('map-diagram-expanded', 'map-stats-expanded');
            }
        }
        
        function hideExpandedMap() {
            document.getElementById('map-modal').style.display = 'none';
        }

        // Close modal when clicking outside of it
        document.addEventListener('click', function(event) {
            const faqModal = document.getElementById('faq-modal');
            const mapModal = document.getElementById('map-modal');
            if (event.target === faqModal) {
                hideFAQ();
            }
            if (event.target === mapModal) {
                hideExpandedMap();
            }
        });
        
        // Close modal with Escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                hideFAQ();
                hideExpandedMap();
            }
        });

        // Initialize the viewer
        // Check which state file is available
        async function initializeViewer() {
            try {
                // Try live file first (works for both local and S3 deployment)
                const response = await fetch('./zorkgpt/current_state.json');
                if (response.ok) {
                    console.log('Using current_state.json (live)');
                    return new ZorkGameViewer('./zorkgpt/current_state.json');
                }
            } catch (e) {
                console.log('current_state.json not available');
            }
            
            try {
                // Fall back to test file (for local development)
                const testResponse = await fetch('./test_current_state.json');
                if (testResponse.ok) {
                    console.log('Using test_current_state.json (fallback)');
                    return new ZorkGameViewer('./test_current_state.json');
                }
            } catch (e) {
                console.log('test_current_state.json not available');
            }
            
            // Show error if no files available
            document.getElementById('episode-id').textContent = 'No state file found';
            document.getElementById('map-diagram').innerHTML = '<p class="error-message">No state files available. Run ZorkGPT with S3 configured or test_state_export.py for local testing.</p>';
            return null;
        }
        
        // Initialize the viewer
        initializeViewer().then(viewer => {
            if (viewer) {
                console.log('ZorkGPT Live Viewer initialized successfully');
                // Store globally so map modal can access it
                window.zorkViewer = viewer;
            }
        });
    </script>
</body>
</html> 
